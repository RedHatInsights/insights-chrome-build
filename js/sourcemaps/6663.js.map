{"version":3,"sources":["webpack:///./src/js/App/GlobalFilter/constants.js","webpack:///./src/js/consts.js","webpack:///./src/js/jwt/constants.js","webpack:///./src/js/jwt/insights/entitlements.js","webpack:///./src/js/jwt/insights/offline.js","webpack:///./src/js/jwt/insights/url.js","webpack:///./src/js/jwt/insights/user.js","webpack:///./src/js/jwt/jwt.js","webpack:///./src/js/jwt/logger.js","webpack:///./src/js/jwt/modules/useChromeAuth.js","webpack:///./src/js/redux/globalFilterReducers.js","webpack:///./src/js/utils.js","webpack:///./src/js/utils/cache.js"],"names":["GLOBAL_FILTER_KEY","escaper","value","replace","memoize","filter","encode","format","Workloads","SID","SID_KEY","tags","mappedTags","flatMap","Object","entries","namespace","item","isSelected","map","tagKey","tagValue","encodeURIComponent","reduce","acc","key","val","join","matcherMapper","isEmpty","isNotEmpty","matchValue","matcher","match","insights","chrome","auth","getUser","identity","user","is_org_admin","is_active","is_internal","appName","entitlements","Boolean","is_entitled","url","method","accessor","options","instance","then","response","get","catch","err","console","log","freeze","noAuthParam","offlineToken","allowedUnauthedPaths","DEFAULT_ROUTES","prod","sso","qa","ci","qaprodauth","stage","realm","clientId","cookieName","BASE_PATH","cachePrefix","cache","bootstrapCache","axios","adapter","interceptors","use","request","fromCache","last","lastActive","keys","localStorage","endsWith","deleteLocalStorageItems","data","ServicesApi","undefined","priv","wipePostbackParamsThatAreNotForUs","getWindow","location","href","indexOf","consts","postbackUrl","hash","urijs","removeQuery","history","pushState","toString","getOfflineToken","ret","Promise","reject","obj","tokenURL","insightsUrl","params","split","result","parts","getPostDataObject","code","entry","config","headers","window","grant_type","client_id","redirect_uri","logger","env","ssoEnv","find","includes","hostname","pathMapper","openshift","migrations","ansible","subscriptions","settings","internal","tryBounceIfUnentitled","section","service","document","baseURI","token","account_number","type","username","email","first_name","last_name","locale","org_id","account_id","buildUser","pathName","pathname","shift","pageAllowsUnentitled","resolve","isValidAccountNumber","servicesApi","jti","servicesGet","res","DEFAULT_COOKIE_NAME","authChannel","BroadcastChannel","decodeToken","str","length","slice","decodeURIComponent","escape","atob","JSON","parse","onmessage","e","logout","login","updateToken","doOffline","removeSearch","addSearch","defaultOptions","promiseType","redirectUri","kc","Keycloak","init","scope","cookie","routes","onLoad","checkLoginIframe","isBeta","silentCheckSsoRedirectUri","host","getItem","keycloak","onTokenExpired","onAuthSuccess","loginAllTabs","onAuthRefreshSuccess","refreshTokens","isExistingValid","authenticated","initSuccess","initError","parsed","exp","now","Date","substr","tokenParsed","refreshToken","setCookie","secure","bounce","clearToken","startsWith","eightSeconds","getTime","expires","logoutAllTabs","postMessage","getUserInfo","jwtCookie","insightsUser","pageRequiresAuthentication","isAuthenticated","expiredToken","refreshed","date","setUTCSeconds","toGMTString","getEncodedToken","Sentry","Error","getUrl","fileName","msg","TIMER_STR","bouncer","allowUnauthed","jwt","timeEnd","flatten","initChromeAuth","time","initPromise","num","Number","isInteger","sections","removeItem","searchString","fallback","curr","accDate","currObj","endpoint","cacheKey","store","createCacheStore","setupCache","maxAge","name","localforage","driver"],"mappings":"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","file":"6663.3c4f57e2ad6500f42f37.js","sourcesContent":["import { deleteLocalStorageItems } from '../../utils';\nimport { decodeToken } from '../../jwt/jwt';\nimport omit from 'lodash/omit';\nimport flatMap from 'lodash/flatMap';\nimport memoize from 'lodash/memoize';\nimport { SID_KEY } from '../../redux/globalFilterReducers';\n\nexport const GLOBAL_FILTER_KEY = 'chrome:global-filter';\nexport const INVENTORY_API_BASE = '/api/inventory/v1';\nexport const workloads = [\n  {\n    name: 'Workloads',\n    noFilter: true,\n    tags: [\n      {\n        tag: { key: 'SAP' },\n      },\n    ],\n    type: 'checkbox',\n  },\n];\n\nexport const updateSelected = (original, namespace, key, value, isSelected, extra) => ({\n  ...original,\n  [namespace]: {\n    ...original?.[namespace],\n    [key]: {\n      ...original?.[namespace]?.[key],\n      isSelected,\n      value,\n      ...extra,\n    },\n  },\n});\n\nexport const createTagsFilter = (tags = []) =>\n  tags.reduce((acc, curr) => {\n    const [namespace, tag] = curr.split('/');\n    const [tagKey, tagValue] = tag?.split('=') || [];\n    return {\n      ...acc,\n      [namespace]: {\n        ...(acc[namespace] || {}),\n        ...(tagKey?.length > 0 && {\n          [`${tagKey}${tagValue ? `=${tagValue}` : ''}`]: {\n            isSelected: true,\n            group: { value: namespace, label: namespace, type: 'checkbox' },\n            item: { tagValue, tagKey },\n          },\n        }),\n      },\n    };\n  }, {});\n\nexport const storeFilter = (tags, token, isEnabled, history) => {\n  deleteLocalStorageItems(Object.keys(localStorage).filter((key) => key.startsWith(GLOBAL_FILTER_KEY)));\n  if (isEnabled) {\n    const searchParams = new URLSearchParams();\n    const [, SIDs, mappedTags] = flatTags(tags, false, true);\n    if (tags?.Workloads) {\n      const currWorkloads = Object.entries(tags?.Workloads || {})?.find(([, { isSelected }]) => isSelected)?.[0];\n      if (currWorkloads) {\n        searchParams.append('workloads', currWorkloads);\n      }\n    }\n    searchParams.append('SIDs', SIDs);\n    searchParams.append('tags', mappedTags);\n\n    history.push({\n      ...history.location,\n      hash: searchParams.toString(),\n    });\n  }\n\n  localStorage.setItem(\n    `${GLOBAL_FILTER_KEY}/${token}`,\n    JSON.stringify(\n      Object.entries(tags).reduce(\n        (acc, [key, value]) => ({\n          ...acc,\n          [key]: {\n            ...Object.entries(value || {}).reduce(\n              (\n                currValue,\n                // eslint-disable-next-line no-unused-vars\n                [itemKey, { item, value: tagValue, group: { items, ...group } = {}, ...rest }]\n              ) => ({\n                ...currValue,\n                [itemKey]: {\n                  ...rest,\n                  item: { tagValue: item?.tagValue || tagValue, tagKey: item?.tagKey || itemKey },\n                  group,\n                },\n              }),\n              {}\n            ),\n          },\n        }),\n        {}\n      )\n    )\n  );\n};\n\nexport const generateFilter = async () => {\n  const searchParams = new URLSearchParams(location.hash?.substring(1));\n  const currToken = decodeToken(await insights.chrome.auth.getToken())?.session_state;\n  let data;\n  try {\n    data = JSON.parse(localStorage.getItem(`${GLOBAL_FILTER_KEY}/${currToken}`) || '{}');\n  } catch (e) {\n    data = {};\n  }\n\n  let { Workloads, [SID_KEY]: SIDs, ...tags } = data;\n\n  if (searchParams.get('workloads')) {\n    const { tag } = workloads[0].tags.find(({ tag: { key } }) => key === searchParams.get('workloads')) || {};\n    Workloads = tag?.key\n      ? {\n          [tag?.key]: {\n            group: omit(workloads[0], 'tags'),\n            isSelected: true,\n            item: { tagKey: tag?.key },\n          },\n        }\n      : data.Workloads;\n  }\n\n  if (typeof searchParams.get('tags') === 'string') {\n    tags = createTagsFilter(searchParams.get('tags')?.split(','));\n  }\n\n  if (typeof searchParams.get('SIDs') === 'string') {\n    SIDs = createTagsFilter(\n      searchParams\n        .get('SIDs')\n        ?.split(',')\n        .map((sid) => `${SID_KEY}/${sid}`)\n    )?.[SID_KEY];\n  }\n\n  return [\n    {\n      Workloads,\n      ...(SIDs && { [SID_KEY]: SIDs }),\n      ...tags,\n    },\n    currToken,\n  ];\n};\n\nexport const escaper = (value) => value.replace(/\\//gi, '%2F').replace(/=/gi, '%3D');\n\nexport const flatTags = memoize(\n  (filter, encode = false, format = false) => {\n    const { Workloads, [SID_KEY]: SID, ...tags } = filter;\n    const mappedTags = flatMap(Object.entries({ ...tags, ...(!format && { Workloads }) } || {}), ([namespace, item]) =>\n      Object.entries(item || {})\n        .filter(([, { isSelected }]) => isSelected)\n        .map(([tagKey, { item, value: tagValue }]) => {\n          return `${namespace ? `${encode ? encodeURIComponent(escaper(namespace)) : escaper(namespace)}/` : ''}${\n            encode ? encodeURIComponent(escaper(item?.tagKey || tagKey)) : escaper(item?.tagKey || tagKey)\n          }${\n            item?.tagValue || tagValue\n              ? `=${encode ? encodeURIComponent(escaper(item?.tagValue || tagValue)) : escaper(item?.tagValue || tagValue)}`\n              : ''\n          }`;\n        })\n    );\n    return format\n      ? [\n          Workloads,\n          Object.entries(SID || {})\n            .filter(([, { isSelected }]) => isSelected)\n            .reduce((acc, [key]) => [...acc, key], []),\n          mappedTags,\n        ]\n      : mappedTags;\n  },\n  (filter = {}, encode, format) =>\n    `${Object.entries(filter)\n      .map(\n        ([namespace, val]) =>\n          `${namespace}.${Object.entries(val || {})\n            .filter(([, { isSelected }]) => isSelected)\n            .map(([key]) => key)\n            .join('')}`\n      )\n      .join(',')}${encode ? '_encode' : ''}${format ? '_format' : ''}`\n);\n","import instance from '@redhat-cloud-services/frontend-components-utilities/interceptors';\nimport get from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\n\nconst obj = {\n  noAuthParam: 'noauth',\n  offlineToken: '2402500adeacc30eb5c5a8a5e2e0ec1f',\n  allowedUnauthedPaths: ['/', '/logout', '/beta', '/security/insights', '/beta/security/insights'],\n};\n\nconst matcherMapper = {\n  isEmpty,\n  isNotEmpty: (value) => !isEmpty(value),\n};\n/**\n * returns true/false if value matches required criteria. If invalid or no matcher is provided it returns the original value.\n * @param {any} value variable to be matched with matcher function\n * @param {string} matcher id of matcher\n */\nconst matchValue = (value, matcher) => {\n  const match = matcherMapper[matcher];\n  return typeof match === 'function' ? match(value) : value;\n};\n\n/**\n * Check if is permitted to see navigation link\n * @param {array} permissions array checked user permissions\n * @param {every|some} require type of permissions requirement\n * @returns {boolean}\n */\nconst checkPermissions = async (permissions = [], require = 'every') => {\n  const userPermissions = await insights.chrome.getUserPermissions();\n  return userPermissions && permissions[require]((item) => userPermissions.find(({ permission }) => permission === item));\n};\n\nexport const visibilityFunctions = {\n  isOrgAdmin: async () => {\n    const { identity } = await insights.chrome.auth.getUser();\n    try {\n      return identity.user.is_org_admin;\n    } catch {\n      return false;\n    }\n  },\n  isActive: async () => {\n    const { identity } = await insights.chrome.auth.getUser();\n    try {\n      return identity.user.is_active;\n    } catch {\n      return false;\n    }\n  },\n  isInternal: async () => {\n    const { identity } = await insights.chrome.auth.getUser();\n    try {\n      return identity.user.is_internal;\n    } catch {\n      return false;\n    }\n  },\n  isEntitled: async (appName) => {\n    const { entitlements } = await insights.chrome.auth.getUser();\n    return entitlements && appName\n      ? Boolean(entitlements[appName] && entitlements[appName].is_entitled)\n      : // eslint-disable-next-line camelcase\n        Object.entries(entitlements || {}).reduce((acc, [key, { is_entitled }]) => ({ ...acc, [key]: is_entitled }), {});\n  },\n  isProd: () => insights.chrome.isProd,\n  isBeta: () => insights.chrome.isBeta(),\n  loosePermissions: (permissions) => checkPermissions(permissions, 'some'),\n  hasPermissions: checkPermissions,\n  apiRequest: async ({ url, method, accessor, matcher, ...options }) => {\n    return instance({\n      url,\n      method: method || 'GET',\n      ...options,\n    })\n      .then((response) => matchValue(accessor ? get(response || {}, accessor) : response, matcher))\n      .catch((err) => {\n        console.log(err);\n        return false;\n      });\n  },\n};\n\nexport const isVisible = (limitedApps, app, visibility) => {\n  if (limitedApps && limitedApps.includes(app)) {\n    if (visibility instanceof Object) {\n      return Boolean(visibility[app]);\n    }\n\n    return visibility;\n  }\n\n  return true;\n};\n\nexport default Object.freeze(obj);\n","// Global Defaults\nexport const DEFAULT_ROUTES = {\n  prod: {\n    url: ['access.redhat.com', 'prod.foo.redhat.com', 'cloud.redhat.com'],\n    sso: 'https://sso.redhat.com/auth',\n  },\n  qa: {\n    url: ['qa.foo.redhat.com', 'qa.cloud.redhat.com'],\n    sso: 'https://sso.qa.redhat.com/auth',\n  },\n  ci: {\n    url: ['ci.foo.redhat.com', 'ci.cloud.redhat.com'],\n    sso: 'https://sso.qa.redhat.com/auth',\n  },\n  qaprodauth: {\n    url: ['qaprodauth.foo.redhat.com', 'qaprodauth.cloud.redhat.com'],\n    sso: 'https://sso.redhat.com/auth',\n  },\n  stage: {\n    url: ['cloud.stage.redhat.com'],\n    sso: 'https://sso.stage.redhat.com/auth',\n  },\n};\n\nexport const options = {\n  realm: 'redhat-external',\n  clientId: 'cloud-services',\n  cookieName: 'cs_jwt',\n};\n\nexport const noAuthParam = 'noauth';\n\nexport const offlineToken = '2402500adeacc30eb5c5a8a5e2e0ec1f';\n\nexport const allowedUnauthedPaths = ['/', '/logout', '/beta', '/security/insights', '/beta/security/insights'];\n","import axios from 'axios';\nimport { ServicesApi } from '@redhat-cloud-services/entitlements-client';\nimport { deleteLocalStorageItems, bootstrapCache, lastActive } from '../../utils';\n\nconst BASE_PATH = '/api/entitlements/v1';\n\nexport default (cachePrefix) => {\n  const cache = bootstrapCache(BASE_PATH, `${cachePrefix}-entitlements`);\n\n  const instance = axios.create({ adapter: cache.adapter });\n  instance.interceptors.response.use((response) => {\n    if (response && response.request && response.request.fromCache !== true) {\n      const last = lastActive('/api/entitlements/v1/services', 'fallback');\n      const keys = Object.keys(localStorage).filter((key) => key.endsWith('/api/entitlements/v1/services') && key !== last);\n\n      deleteLocalStorageItems(keys);\n    }\n\n    return response.data || response;\n  });\n  return new ServicesApi(undefined, BASE_PATH, instance);\n};\n","import consts from '../../consts';\nimport { DEFAULT_ROUTES } from '../constants';\nimport insightsUrl from './url';\nimport axios from 'axios';\nimport urijs from 'urijs';\n\nconst priv = {};\n// note this function is not exposed\n// it is a run everytime and produce some side affect thing\n// if a special condition is encountered\n//\n// it would be great to not have this behave this way\n// but the order that this needs to run in is very specific\n// so that is somewhat difficult\nexport function wipePostbackParamsThatAreNotForUs() {\n  if (getWindow().location.href.indexOf(consts.offlineToken) !== -1) {\n    // this is a UHC offline token postback\n    // we need to not let the JWT lib see this\n    // and try to use it\n    priv.postbackUrl = getWindow().location.href;\n\n    // we do this because keycloak.js looks at the hash for its parameters\n    // and if found uses the params for its own use\n    //\n    // in the UHC offline post back case we *dont*\n    // want the params to be used by keycloak.js\n    // so we have to destroy this stuff and let regular auth routines happen\n    getWindow().location.hash = '';\n\n    // nuke the params so that people dont see the ugly\n    const url = urijs(getWindow().location.href);\n    url.removeQuery(consts.noAuthParam);\n    getWindow().history.pushState('offlinePostback', '', url.toString());\n  }\n}\n\nexport function getOfflineToken(realm, clientId) {\n  const postbackUrl = getPostbackUrl();\n\n  if (!postbackUrl) {\n    // we need this postback URL because it contains parameters needed to\n    // call KC for the actual offline token\n    // thus we cant continue if it is missing\n    return Promise.reject('not available');\n  }\n\n  const tokenURL = `${insightsUrl(DEFAULT_ROUTES)}/realms/${realm}/protocol/openid-connect/token`;\n  const params = parseHashString(postbackUrl);\n\n  return axios({\n    method: 'post',\n    url: tokenURL,\n    data: getPostDataString(getPostDataObject(postbackUrl, clientId, params.code)),\n    config: { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } },\n  });\n}\n\nfunction getWindow() {\n  return window;\n}\n\nfunction getPostbackUrl() {\n  // let folks only do this once\n  const ret = priv.postbackUrl;\n  delete priv.postbackUrl;\n  return ret;\n}\n\nfunction getPostDataObject(url, clientId, code) {\n  return {\n    code: code,\n    grant_type: 'authorization_code', // eslint-disable-line camelcase\n    client_id: clientId, // eslint-disable-line camelcase\n    redirect_uri: encodeURIComponent(url.split('#')[0]), // eslint-disable-line camelcase\n  };\n}\n\nfunction parseHashString(str) {\n  return str\n    .split('#')[1]\n    .split('&')\n    .reduce((result, item) => {\n      const parts = item.split('=');\n      result[parts[0]] = parts[1];\n      return result;\n    }, {});\n}\n\nfunction getPostDataString(obj) {\n  return Object.entries(obj)\n    .map((entry) => {\n      return `${entry[0]}=${entry[1]}`;\n    })\n    .join('&');\n}\n","import logger from '../logger';\nconst log = logger('insights/url.js');\n\n// Parse through keycloak options routes\nexport default (env) => {\n  const ssoEnv = Object.entries(env).find(([, { url }]) => url.includes(location.hostname));\n\n  if (ssoEnv) {\n    log(`SSO Url: ${ssoEnv?.[1].sso}`);\n    log(`Current env: ${ssoEnv?.[0]}`);\n    return ssoEnv?.[1].sso;\n  } else {\n    log('SSO url: not found, defaulting to qa');\n    log('Current env: not found, defaultint to qa');\n    return 'https://sso.qa.redhat.com/auth';\n  }\n};\n","import { pageAllowsUnentitled, isValidAccountNumber } from '../../utils';\nimport servicesApi from './entitlements';\nimport logger from '../logger';\nconst log = logger('insights/user.js');\nconst pathMapper = {\n  'cost-management': 'cost_management',\n  insights: 'insights',\n  openshift: 'openshift',\n  migrations: 'migrations',\n  ansible: 'ansible',\n  subscriptions: 'subscriptions',\n  settings: 'settings',\n  'user-preferences': 'user_preferences',\n  internal: 'internal',\n};\n\nfunction getWindow() {\n  return window;\n}\n\n/* eslint-disable camelcase */\nfunction buildUser(token) {\n  const user = token\n    ? {\n        identity: {\n          account_number: token.account_number,\n          type: token.type,\n          user: {\n            username: token.username,\n            email: token.email,\n            first_name: token.first_name,\n            last_name: token.last_name,\n            is_active: token.is_active,\n            is_org_admin: token.is_org_admin,\n            is_internal: token.is_internal,\n            locale: token.locale,\n          },\n          internal: {\n            org_id: token.org_id,\n            account_id: token.account_id,\n          },\n        },\n      }\n    : null;\n\n  return user;\n}\n/* eslint-enable camelcase */\n\nfunction tryBounceIfUnentitled(data, section) {\n  // only test this on the apps that are in valid sections\n  // we need to keep /apps and other things functional\n  if (\n    section !== 'insights' &&\n    section !== 'openshift' &&\n    section !== 'cost-management' &&\n    section !== 'migrations' &&\n    section !== 'ansible' &&\n    section !== 'subscriptions' &&\n    section !== 'settings' &&\n    section !== 'user-preferences' &&\n    section !== 'internal'\n  ) {\n    return;\n  }\n\n  const service = pathMapper[section];\n  if (data === true) {\n    // this is a force bounce scenario!\n    getWindow().location.replace(`${document.baseURI}?not_entitled=${service}`);\n  }\n\n  if (section && section !== '') {\n    if (data[service] && data[service].is_entitled) {\n      log(`Entitled to: ${service}`);\n    } else {\n      log(`Not entitled to: ${service}`);\n      getWindow().location.replace(`${document.baseURI}?not_entitled=${service}`);\n    }\n  }\n}\n\nexport default (token) => {\n  let user = buildUser(token);\n\n  const pathName = getWindow().location.pathname.split('/');\n  pathName.shift();\n  if (pathName[0] === 'beta') {\n    pathName.shift();\n  }\n\n  if (user) {\n    log(`Account Number: ${user.identity.account_number}`);\n\n    // NOTE: Openshift supports Users with Account Number of -1\n    // thus we need to bypass here\n    // dont call entitlements on / /beta /openshift or /beta/openshift\n    //\n    // Landing Page *does* support accounts with -1\n    // it has to\n    if (pageAllowsUnentitled()) {\n      return new Promise((resolve) => {\n        user.identity = {\n          ...user.identity,\n          entitlements: {},\n        };\n        resolve(user);\n      });\n    }\n\n    // Important this has to come after the above -1 allow checks\n    // Otherwise we get bounced on those paths\n    //\n    // It also needs to not go int he servicesApi call\n    // because 3scale 403s if the Account number is -1\n    //\n    // we \"force\" a bounce here because the entitlements API\n    // was never called\n    if (!isValidAccountNumber(user.identity.account_number)) {\n      tryBounceIfUnentitled(true, pathName[0]);\n      return;\n    }\n\n    return servicesApi(token.jti)\n      .servicesGet()\n      .then((data) => {\n        tryBounceIfUnentitled(data, pathName[0]);\n        return {\n          ...user,\n          entitlements: data,\n        };\n      });\n  } else {\n    log('User not ready');\n  }\n\n  return new Promise((res) => res());\n};\n","// Imports\nimport Keycloak from '@redhat-cloud-services/keycloak-js';\nimport { BroadcastChannel } from 'broadcast-channel';\nimport cookie from 'js-cookie';\nimport { pageRequiresAuthentication } from '../utils';\nimport * as Sentry from '@sentry/browser';\nimport { GLOBAL_FILTER_KEY } from '../App/GlobalFilter/constants';\nimport { deleteLocalStorageItems } from '../utils';\nimport logger from './logger';\n\n// Insights Specific\nimport insightsUrl from './insights/url';\nimport insightsUser from './insights/user';\nimport urijs from 'urijs';\nimport { DEFAULT_ROUTES, options as defaultOptions } from './constants';\n\nconst log = logger('jwt.js');\nconst DEFAULT_COOKIE_NAME = 'cs_jwt';\n\nconst priv = {};\n\n// Broadcast Channel\nconst authChannel = new BroadcastChannel('auth');\nauthChannel.onmessage = (e) => {\n  if (e && e.data && e.data.type) {\n    log(`BroadcastChannel, Received event : ${e.data.type}`);\n\n    switch (e.data.type) {\n      case 'logout':\n        return logout();\n      case 'login':\n        return login();\n      case 'refresh':\n        return updateToken();\n    }\n  }\n};\n\nexport function decodeToken(str) {\n  str = str.split('.')[1];\n  str = str.replace('/-/g', '+');\n  str = str.replace('/_/g', '/');\n  switch (str.length % 4) {\n    case 0:\n      break;\n    case 2:\n      str += '==';\n      break;\n    case 3:\n      str += '=';\n      break;\n    default:\n      throw 'Invalid token';\n  }\n\n  str = (str + '===').slice(0, str.length + (str.length % 4));\n  str = str.replace(/-/g, '+').replace(/_/g, '/');\n  str = decodeURIComponent(escape(atob(str)));\n  str = JSON.parse(str);\n\n  return str;\n}\n\nexport const doOffline = (key, val) => {\n  const url = urijs(window.location.href);\n  url.removeSearch(key);\n  url.addSearch(key, val);\n\n  const options = {\n    ...defaultOptions,\n    promiseType: 'native',\n    redirectUri: url.toString(),\n    url: insightsUrl(DEFAULT_ROUTES),\n  };\n\n  const kc = Keycloak(options);\n  kc.init(options).then(() => {\n    kc.login({\n      scope: 'offline_access',\n    });\n  });\n};\n\n/*** Initialization ***/\nexport const init = (options) => {\n  log('Initializing');\n\n  const cookieName = options.cookieName ? options.cookieName : DEFAULT_COOKIE_NAME;\n\n  priv.cookie = {\n    cookieName,\n  };\n  //constructor for new Keycloak Object?\n  options.url = insightsUrl(options.routes ? options.routes : DEFAULT_ROUTES);\n  options.clientId = 'cloud-services';\n  options.realm = 'redhat-external';\n\n  //options for keycloak.init method\n  options.promiseType = 'native';\n  options.onLoad = 'check-sso';\n  options.checkLoginIframe = false;\n\n  const isBeta = window.location.pathname.split('/')[1] === 'beta' ? '/beta' : '';\n\n  options.silentCheckSsoRedirectUri = `https://${window.location.host}${isBeta}/silent-check-sso.html`;\n\n  if (window.localStorage && window.localStorage.getItem('chrome:jwt:shortSession') === 'true') {\n    options.realm = 'short-session';\n  }\n\n  //priv.keycloak = Keycloak(options);\n  priv.keycloak = Keycloak(options);\n  priv.keycloak.onTokenExpired = updateToken;\n  priv.keycloak.onAuthSuccess = loginAllTabs;\n  priv.keycloak.onAuthRefreshSuccess = refreshTokens;\n\n  if (options.token) {\n    if (isExistingValid(options.token)) {\n      // we still need to init async\n      // so that the renewal times and such fire\n      priv.keycloak.init(options);\n\n      return new Promise((resolve) => {\n        // Here we have an existing key\n        // We need to set up some of the keycloak state\n        // so that the reset of the methods that Chrome uses\n        // to check if things are good get faked out\n        // TODO reafctor the direct access to priv.keycloak\n        // away from the users\n        priv.keycloak.authenticated = true;\n        priv.keycloak.token = options.token;\n        resolve();\n      });\n    } else {\n      delete options.token;\n    }\n  }\n\n  return priv.keycloak.init(options).then(initSuccess).catch(initError);\n};\n\nfunction isExistingValid(token) {\n  log('Checking validity of existing JWT');\n  try {\n    if (!token) {\n      return false;\n    }\n\n    const parsed = decodeToken(token);\n    if (!parsed.exp) {\n      return false;\n    }\n\n    // Date.now() has extra precision...\n    // it includes milis\n    // we need to trim it down to valid seconds from epoch\n    // because we compare to KC's exp which is seconds from epoch\n    const now = Date.now().toString().substr(0, 10);\n    const exp = parsed.exp - now;\n\n    log(`Token expires in ${exp}`);\n\n    // We want to invalidate tokens if they are getting close\n    // to the expiry time\n    // So that we can be someone safe from time skew\n    // issues on our APIs\n    // i.e. the client could have a slight time skew\n    // and the API is true (because NTP) and we could send down\n    // a JWT that is actually exipred\n    if (exp > 90) {\n      priv.keycloak.tokenParsed = parsed;\n      return true;\n    } else {\n      if (exp > 0) {\n        log('token is expiring in < 90 seconds');\n      } else {\n        log('token is expired');\n      }\n\n      return false;\n    }\n  } catch (e) {\n    log(e);\n    return false;\n  }\n}\n\n// keycloak init successful\nfunction initSuccess() {\n  log('JWT Initialized');\n  setCookie(priv.keycloak.token);\n  setRefresh(priv.keycloak.refreshToken);\n}\n\n// keycloak init failed\nfunction initError() {\n  log('JWT init error');\n  logout();\n}\n\n/*** Login/Logout ***/\nexport function login() {\n  log('Logging in');\n  // Redirect to login\n  cookie.set('cs_loggedOut', 'false');\n  return priv.keycloak.login({ redirectUri: location.href });\n}\n\nfunction logout(bounce) {\n  log('Logging out');\n\n  // Clear cookies and tokens\n  priv.keycloak.clearToken();\n  cookie.remove(priv.cookie.cookieName);\n  cookie.remove('cs_demo');\n\n  const isBeta = window.location.pathname.split('/')[1] === 'beta' ? '/beta' : '';\n  const keys = Object.keys(localStorage).filter(\n    (key) =>\n      key.endsWith('/api/entitlements/v1/services') ||\n      key.endsWith('/config/main.yml') ||\n      key.endsWith('/chrome') ||\n      key.endsWith('/chrome-store') ||\n      key.startsWith('kc-callback') ||\n      key.startsWith(GLOBAL_FILTER_KEY)\n  );\n  deleteLocalStorageItems(keys);\n  // Redirect to logout\n  if (bounce) {\n    let eightSeconds = new Date(new Date().getTime() + 8 * 1000);\n    cookie.set('cs_loggedOut', 'true', {\n      expires: eightSeconds,\n    });\n    priv.keycloak.logout({\n      redirectUri: `https://${window.location.host}${isBeta}`,\n    });\n  }\n}\n\nexport const logoutAllTabs = (bounce) => {\n  authChannel.postMessage({ type: 'logout' });\n  logout(bounce);\n};\n\nfunction loginAllTabs() {\n  authChannel.postMessage({ type: 'login' });\n}\n\n/*** User Functions ***/\n// Get user information\nexport const getUserInfo = () => {\n  log('Getting User Information');\n  const jwtCookie = cookie.get(DEFAULT_COOKIE_NAME);\n\n  if (jwtCookie && isExistingValid(jwtCookie) && isExistingValid(priv.keycloak.token)) {\n    return insightsUser(priv.keycloak.tokenParsed);\n  }\n\n  return updateToken()\n    .then(() => {\n      insightsUser(priv.keycloak.tokenParsed);\n      log('Successfully updated token');\n    })\n    .catch(() => {\n      if (pageRequiresAuthentication()) {\n        log('Trying to log in user to refresh token');\n        return login();\n      }\n    });\n};\n\n// Check to see if the user is loaded, this is what API calls should wait on\nexport const isAuthenticated = () => {\n  log(`User Ready: ${priv.keycloak.authenticated}`);\n  return priv.keycloak.authenticated;\n};\n\n/*** Check Token Status ***/\n// If a token is expired, logout of all tabs\nexport const expiredToken = () => {\n  log('Token has expired, trying to log out');\n  logout();\n};\n\n// Broadcast message to refresh tokens across tabs\nfunction refreshTokens() {\n  authChannel.postMessage({ type: 'refresh' });\n}\n\n// Actually update the token\nfunction updateToken() {\n  return priv.keycloak\n    .updateToken()\n    .then((refreshed) => {\n      // Important! after we update the token\n      // we have to again populate the Cookie!\n      // Otherwise we just update and dont send\n      // the updated token down stream... and things 401\n      setCookie(priv.keycloak.token);\n\n      log('Attempting to update token');\n\n      if (refreshed) {\n        log('Token was successfully refreshed');\n      } else {\n        log('Token is still valid, not updating');\n      }\n    })\n    .catch(() => {\n      /**\n       * The \"priv.keycloak.updateToken\" promise does not return any error message\n       */\n      log('Token update failed');\n    });\n}\n\nfunction getCookieExpires(exp) {\n  // we want the cookie to expire at the same time as the JWT session\n  // so we take the exp and get a new GTMString from that\n  const date = new Date(0);\n  date.setUTCSeconds(exp);\n  return date.toGMTString();\n}\n\n// Set the cookie for 3scale\nfunction setCookie(token) {\n  log('Setting the cs_jwt cookie');\n  if (token && token.length > 10) {\n    setCookieWrapper(`${priv.cookie.cookieName}=${token};` + `path=/;` + `secure=true;` + `expires=${getCookieExpires(decodeToken(token).exp)}`);\n  }\n}\n\nfunction setRefresh(refreshToken) {\n  log('Setting the refresh token');\n  cookie.set('cs_jwt_refresh', refreshToken, { secure: true });\n}\n\n// do this so we can mock out for test\nfunction setCookieWrapper(str) {\n  document.cookie = str;\n}\n\n// Encoded WIP\nexport const getEncodedToken = () => {\n  log('Trying to get the encoded token');\n\n  if (!isExistingValid(priv.keycloak.token)) {\n    Sentry.captureException(new Error('Fetching token failed - expired token'));\n    log('Failed to get encoded token');\n    updateToken();\n  }\n\n  return priv.keycloak.token;\n};\n\n// Keycloak server URL\nexport const getUrl = () => {\n  return insightsUrl(DEFAULT_ROUTES);\n};\n","// const pub = {};\n\nexport default (fileName) => {\n  return (msg) => {\n    if (window.console) {\n      if (window.localStorage && window.localStorage.getItem('chrome:jwt:debug')) {\n        window.console.log(`[JWT][${fileName}] ${msg}`);\n      }\n    }\n  };\n};\n","import { wipePostbackParamsThatAreNotForUs, getOfflineToken } from '../insights/offline';\n\nimport flatten from 'lodash/flatten';\n\nimport * as jwt from '../jwt';\nimport cookie from 'js-cookie';\nimport { options as defaultOptions, allowedUnauthedPaths } from '../constants';\nconst TIMER_STR = '[JWT][jwt.js] Auth time';\n\nfunction bouncer() {\n  if (allowUnauthed()) {\n    return;\n  }\n\n  if (!jwt.isAuthenticated()) {\n    cookie.remove(defaultOptions.cookieName);\n    jwt.login();\n  }\n\n  console.timeEnd(TIMER_STR); // eslint-disable-line no-console\n}\n\nfunction getAllowedUnauthedPaths() {\n  return flatten(allowedUnauthedPaths.map((e) => [e, e + '/']));\n}\n\nexport function allowUnauthed() {\n  if (getAllowedUnauthedPaths().includes(window.location.pathname)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport const initChromeAuth = () => {\n  console.time(TIMER_STR); // eslint-disable-line no-console\n  let options = {\n    ...defaultOptions,\n  };\n\n  wipePostbackParamsThatAreNotForUs();\n  const token = cookie.get(options.cookieName);\n\n  // If we find an existing token, use it\n  // so that we dont auth even when a valid token is present\n  // otherwise its quick, but we bounce around and get a new token\n  // on every page load\n  if (token && token.length > 10) {\n    options.token = token;\n    options.refreshToken = cookie.get('cs_jwt_refresh');\n  }\n\n  const promise = jwt.init(options).then(bouncer);\n\n  return {\n    initPromise: promise,\n  };\n};\n\nconst useChromeAuth = () => {\n  let options = {\n    ...defaultOptions,\n  };\n\n  return {\n    getOfflineToken: () => {\n      return getOfflineToken(options.realm, options.clientId);\n    },\n    ...jwt,\n  };\n};\n\nexport default useChromeAuth;\n","import groupBy from 'lodash/groupBy';\nexport const SID_KEY = 'SAP ID (SID)';\n\nexport const defaultState = {\n  tags: { isLoaded: false, items: [] },\n  sid: { isLoaded: false, items: [] },\n  workloads: { isLoaded: false, items: {} },\n};\n\nexport function onGetAllTags(state, { payload }) {\n  return {\n    ...state,\n    tags: {\n      isLoaded: true,\n      items: Object.entries(groupBy(payload?.results || [], ({ tag: { namespace } }) => namespace)).map(([key, value]) => ({\n        name: key,\n        tags: value,\n      })),\n      total: payload?.total,\n      count: payload?.count,\n      page: payload?.page,\n      // eslint-disable-next-line camelcase\n      perPage: payload?.per_page,\n    },\n  };\n}\n\nexport function onGetAllTagsPending(state) {\n  return {\n    ...state,\n    tags: {\n      isLoaded: false,\n    },\n  };\n}\n\nexport function onSetGlobalFilterScope(state, { payload }) {\n  return {\n    ...state,\n    scope: payload,\n  };\n}\n\nexport function onGlobalFilterToggle(state, { payload }) {\n  return {\n    ...state,\n    globalFilterHidden: payload.isHidden,\n  };\n}\n\nexport function onTagSelect(state, { payload }) {\n  return {\n    ...state,\n    selectedTags: payload,\n  };\n}\n\nexport function onGetAllSIDs(state, { payload }) {\n  return {\n    ...state,\n    sid: {\n      isLoaded: true,\n      ...(payload?.total > 0 && {\n        items: [\n          {\n            name: SID_KEY,\n            tags: (payload?.results || []).map(({ value, count } = {}) => ({\n              tag: { key: value, namespace: SID_KEY },\n              count,\n            })),\n          },\n        ],\n      }),\n      total: payload?.total,\n      count: payload?.count,\n      page: payload?.page,\n      // eslint-disable-next-line camelcase\n      perPage: payload?.per_page,\n    },\n  };\n}\n\nexport function onGetAllSIDsPending(state) {\n  return {\n    ...state,\n    sid: {\n      isLoaded: false,\n    },\n  };\n}\n\nexport function onGetAllWorkloads(state, { payload }) {\n  return {\n    ...state,\n    workloads: {\n      isLoaded: true,\n      hasSap: payload?.results?.find(({ value } = {}) => value)?.count || 0,\n    },\n  };\n}\n\nexport function onGetAllWorkloadsPending(state) {\n  return {\n    ...state,\n    workloads: {\n      isLoaded: false,\n    },\n  };\n}\n\nexport function onGlobalFilterRemove(state, { payload }) {\n  return {\n    ...state,\n    globalFilterRemoved: payload.isHidden,\n  };\n}\n","import get from 'lodash/get';\nimport { setupCache } from 'axios-cache-adapter';\nimport { createCacheStore } from './utils/cache';\nimport { DEFAULT_ROUTES } from './jwt/constants';\n\nexport function getWindow() {\n  return window;\n}\n\n/* eslint-disable curly */\nexport function isValidAccountNumber(num) {\n  if (!num) return false;\n  if (num === -1) return false;\n  if (num === '-1') return false;\n  return Number.isInteger(Number(num));\n}\n/* eslint-enable curly */\n\nfunction getSection() {\n  const sections = getWindow().location.pathname.split('/');\n  if (sections[1] === 'beta') {\n    return sections[2] || '';\n  }\n\n  return sections[1];\n}\n\nexport function pageAllowsUnentitled() {\n  const pathname = getWindow().location.pathname;\n  if (\n    pathname === '/' ||\n    pathname === '/beta' ||\n    pathname === '/beta/' ||\n    pathname.indexOf('/openshift') === 0 ||\n    pathname.indexOf('/beta/openshift') === 0 ||\n    pathname.indexOf('/security') === 0 ||\n    pathname.indexOf('/beta/security') === 0\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function pageRequiresAuthentication() {\n  const section = getSection();\n  if (\n    section === 'insights' ||\n    section === 'cost-management' ||\n    section === 'apps' ||\n    section === 'ansible' ||\n    section === 'migrations' ||\n    section === 'subscriptions' ||\n    section === 'openshift' ||\n    section === 'settings' ||\n    section === 'user-preferences' ||\n    section === 'internal'\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Creates a redux listener that watches the state on given path (e.g. chrome.appNav) and calls\n * the given function when the state on the given path changes.\n *\n * The function is called with two parameters: current state value on the path, store reference\n */\nexport function createReduxListener(store, path, fn) {\n  let previous = undefined;\n\n  return () => {\n    const state = store.getState();\n    const current = get(state, path);\n\n    if (current !== previous) {\n      previous = current;\n      fn(current, store);\n    }\n  };\n}\n\nexport function deleteLocalStorageItems(keys) {\n  keys.map((key) => localStorage.removeItem(key));\n}\n\nexport function lastActive(searchString, fallback) {\n  return Object.keys(localStorage).reduce((acc, curr) => {\n    if (curr.includes(searchString)) {\n      try {\n        let accDate;\n        try {\n          accDate = new Date(JSON.parse(localStorage.getItem(acc).expires));\n        } catch {\n          accDate = new Date();\n        }\n\n        const currObj = JSON.parse(localStorage.getItem(curr));\n        return accDate >= new Date(currObj.expires) ? acc : curr;\n      } catch (e) {\n        return acc;\n      }\n    }\n\n    return acc;\n  }, fallback);\n}\n\nexport function bootstrapCache(endpoint, cacheKey) {\n  const store = createCacheStore(endpoint, cacheKey);\n  return setupCache({\n    store,\n    maxAge: 10 * 60 * 1000, // 10 minutes\n  });\n}\n\nexport function getUrl(type) {\n  if (window.location.pathname === ('/beta' || '/')) {\n    return 'landing';\n  }\n\n  const sections = window.location.pathname.split('/');\n  if (sections[1] === 'beta') {\n    return type === 'bundle' ? sections[2] : sections[3];\n  }\n\n  return type === 'bundle' ? sections[1] : sections[2];\n}\n\nexport function getEnv() {\n  return Object.entries(DEFAULT_ROUTES).find(([, { url }]) => url.includes(location.hostname))?.[0] || 'qa';\n}\n\nexport function isBeta() {\n  return window.location.pathname.split('/')[1] === 'beta' ? true : false;\n}\n\nexport function updateDocumentTitle(title) {\n  if (typeof title === 'undefined') {\n    return;\n  }\n  if (typeof title === 'string') {\n    document.title = title;\n  } else {\n    console.warn(`Title is not a string. Got ${typeof title} instead.`);\n  }\n}\n","import { lastActive, deleteLocalStorageItems } from '../utils';\n\nimport localforage from 'localforage';\n\nexport const createCacheStore = (endpoint, cacheKey) => {\n  const name = lastActive(endpoint, cacheKey);\n\n  return localforage.createInstance({\n    driver: [localforage.LOCALSTORAGE],\n    name: name?.split('/')[0] || name,\n  });\n};\n\nlet store;\n\n/**\n * Check if the app has switched between beta/non-beta envs.\n * If it did, we clean the existing chrome cache to prevent stale cache entry.\n * This issue may occur when the user switches between envs without logging out and in.\n */\nconst envSwap = () => {\n  const currentEnv = window.insights.chrome.isBeta() ? 'beta' : 'non-beta';\n  const prevEnv = localStorage.getItem('chrome:prevEnv');\n  if (prevEnv && currentEnv !== prevEnv) {\n    deleteLocalStorageItems(Object.keys(localStorage).filter((item) => item.endsWith('/chrome-store')));\n  }\n  localStorage.setItem('chrome:prevEnv', currentEnv);\n};\n\nexport class CacheAdapter {\n  constructor(endpoint, cacheKey, maxAge = 10 * 60 * 1000) {\n    this.maxAge = maxAge;\n    this.expires = new Date().getTime() + this.maxAge;\n    envSwap();\n    if (!store) {\n      const name = lastActive(endpoint, cacheKey);\n      let cached;\n      try {\n        cached = JSON.parse(localStorage.getItem(name));\n      } catch (e) {\n        cached = localStorage.getItem(name);\n      }\n      this.name = name;\n      this.endpoint = endpoint;\n      this.cacheKey = cacheKey;\n      store = createCacheStore(endpoint, cacheKey);\n      if (new Date(parseInt(cached?.expires, 10)) >= new Date()) {\n        this.setCache(parseInt(cached?.expires, 10), cached?.data);\n      } else {\n        const cacheTime = new Date().getTime() + this.maxAge;\n        this.setCache(cacheTime, {});\n      }\n    }\n  }\n\n  async setCache(expires, data) {\n    this.expires = expires;\n    await store.setItem(this.endpoint, {\n      data,\n      expires,\n    });\n  }\n\n  async invalidateStore() {\n    if (new Date(this.expires) <= new Date()) {\n      deleteLocalStorageItems(Object.keys(localStorage).filter((item) => item.endsWith('/chrome')));\n      await localforage.dropInstance();\n      store = createCacheStore(this.endpoint, this.cacheKey);\n      const cacheTime = new Date().getTime() + this.maxAge;\n      await this.setCache(cacheTime, {});\n    }\n  }\n\n  async setItem(key, data) {\n    await this.invalidateStore();\n    const cachedData = await store.getItem(this.endpoint);\n    cachedData.data = {\n      ...cachedData?.data,\n      [key]: data,\n    };\n    await store.setItem(this.endpoint, cachedData);\n  }\n\n  async getItem(key) {\n    await this.invalidateStore();\n    const cachedData = await store.getItem(this.endpoint);\n    return cachedData?.data?.[key];\n  }\n}\n"],"sourceRoot":""}