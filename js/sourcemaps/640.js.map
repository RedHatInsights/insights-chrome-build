{"version":3,"sources":["webpack:///./src/js/App/GlobalFilter/constants.js","webpack:///./src/js/consts.js","webpack:///./src/js/jwt/constants.js","webpack:///./src/js/jwt/insights/entitlements.js","webpack:///./src/js/jwt/insights/offline.js","webpack:///./src/js/jwt/insights/url.js","webpack:///./src/js/jwt/insights/user.js","webpack:///./src/js/jwt/jwt.js","webpack:///./src/js/jwt/logger.js","webpack:///./src/js/jwt/modules/useChromeAuth.js","webpack:///./src/js/redux/globalFilterReducers.js","webpack:///./src/js/utils.js","webpack:///./src/js/utils/cache.js"],"names":["GLOBAL_FILTER_KEY","escaper","value","replace","memoize","filter","encode","format","Workloads","SID","SID_KEY","tags","mappedTags","flatMap","Object","entries","namespace","item","isSelected","map","tagKey","tagValue","encodeURIComponent","reduce","acc","key","val","join","matcherMapper","isEmpty","isNotEmpty","matchValue","matcher","match","insights","chrome","auth","getUser","identity","user","is_org_admin","is_active","is_internal","appName","entitlements","Boolean","is_entitled","url","method","accessor","options","instance","then","response","get","catch","err","console","log","freeze","noAuthParam","offlineToken","allowedUnauthedPaths","DEFAULT_ROUTES","prod","sso","qa","ci","qaprodauth","stage","realm","clientId","cookieName","BASE_PATH","cachePrefix","cache","bootstrapCache","axios","adapter","interceptors","use","request","fromCache","last","lastActive","keys","localStorage","endsWith","deleteLocalStorageItems","data","ServicesApi","undefined","priv","wipePostbackParamsThatAreNotForUs","getWindow","location","href","indexOf","consts","postbackUrl","hash","urijs","removeQuery","history","pushState","toString","getOfflineToken","ret","Promise","reject","obj","tokenURL","insightsUrl","params","split","result","parts","getPostDataObject","code","entry","config","headers","window","grant_type","client_id","redirect_uri","logger","env","ssoEnv","find","includes","hostname","pathMapper","openshift","migrations","ansible","subscriptions","settings","internal","buildUser","token","account_number","type","username","email","first_name","last_name","locale","org_id","account_id","tryBounceIfUnentitled","section","service","document","baseURI","pathName","pathname","shift","servicesApi","jti","servicesGet","pageAllowsUnentitled","isValidAccountNumber","DEFAULT_COOKIE_NAME","authChannel","BroadcastChannel","decodeToken","str","length","slice","decodeURIComponent","escape","atob","JSON","parse","onmessage","e","logout","login","updateToken","doOffline","removeSearch","addSearch","defaultOptions","promiseType","redirectUri","kc","Keycloak","init","scope","cookie","routes","onLoad","checkLoginIframe","isBeta","silentCheckSsoRedirectUri","host","getItem","keycloak","onTokenExpired","onAuthSuccess","loginAllTabs","onAuthRefreshSuccess","refreshTokens","isExistingValid","resolve","authenticated","initSuccess","initError","parsed","exp","now","Date","substr","tokenParsed","refreshToken","setCookie","secure","bounce","clearToken","startsWith","eightSeconds","getTime","expires","logoutAllTabs","postMessage","getUserInfo","jwtCookie","insightsUser","pageRequiresAuthentication","isAuthenticated","expiredToken","refreshed","date","setUTCSeconds","toGMTString","getEncodedToken","Sentry","Error","getUrl","fileName","msg","TIMER_STR","bouncer","allowUnauthed","jwt","timeEnd","flatten","initChromeAuth","time","initPromise","num","Number","isInteger","sections","removeItem","searchString","fallback","curr","accDate","currObj","endpoint","cacheKey","store","createCacheStore","setupCache","maxAge","name","localforage","driver"],"mappings":"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","file":"640.c87b9097f44ca57feacd.js","sourcesContent":["import { deleteLocalStorageItems } from '../../utils';\nimport { decodeToken } from '../../jwt/jwt';\nimport omit from 'lodash/omit';\nimport flatMap from 'lodash/flatMap';\nimport memoize from 'lodash/memoize';\nimport { SID_KEY } from '../../redux/globalFilterReducers';\n\nexport const GLOBAL_FILTER_KEY = 'chrome:global-filter';\nexport const INVENTORY_API_BASE = '/api/inventory/v1';\nexport const workloads = [\n  {\n    name: 'Workloads',\n    noFilter: true,\n    tags: [\n      {\n        tag: { key: 'SAP' },\n      },\n    ],\n    type: 'checkbox',\n  },\n];\n\nexport const updateSelected = (original, namespace, key, value, isSelected, extra) => ({\n  ...original,\n  [namespace]: {\n    ...original?.[namespace],\n    [key]: {\n      ...original?.[namespace]?.[key],\n      isSelected,\n      value,\n      ...extra,\n    },\n  },\n});\n\nexport const createTagsFilter = (tags = []) =>\n  tags.reduce((acc, curr) => {\n    const [namespace, tag] = curr.split('/');\n    const [tagKey, tagValue] = tag?.split('=') || [];\n    return {\n      ...acc,\n      [namespace]: {\n        ...(acc[namespace] || {}),\n        ...(tagKey?.length > 0 && {\n          [`${tagKey}${tagValue ? `=${tagValue}` : ''}`]: {\n            isSelected: true,\n            group: { value: namespace, label: namespace, type: 'checkbox' },\n            item: { tagValue, tagKey },\n          },\n        }),\n      },\n    };\n  }, {});\n\nexport const storeFilter = (tags, token, isEnabled, history) => {\n  deleteLocalStorageItems(Object.keys(localStorage).filter((key) => key.startsWith(GLOBAL_FILTER_KEY)));\n  if (isEnabled) {\n    const searchParams = new URLSearchParams();\n    const [, SIDs, mappedTags] = flatTags(tags, false, true);\n    if (tags?.Workloads) {\n      const currWorkloads = Object.entries(tags?.Workloads || {})?.find(([, { isSelected }]) => isSelected)?.[0];\n      if (currWorkloads) {\n        searchParams.append('workloads', currWorkloads);\n      }\n    }\n    searchParams.append('SIDs', SIDs);\n    searchParams.append('tags', mappedTags);\n\n    history.push({\n      ...history.location,\n      hash: searchParams.toString(),\n    });\n  }\n\n  localStorage.setItem(\n    `${GLOBAL_FILTER_KEY}/${token}`,\n    JSON.stringify(\n      Object.entries(tags).reduce(\n        (acc, [key, value]) => ({\n          ...acc,\n          [key]: {\n            ...Object.entries(value || {}).reduce(\n              (\n                currValue,\n                // eslint-disable-next-line no-unused-vars\n                [itemKey, { item, value: tagValue, group: { items, ...group } = {}, ...rest }]\n              ) => ({\n                ...currValue,\n                [itemKey]: {\n                  ...rest,\n                  item: { tagValue: item?.tagValue || tagValue, tagKey: item?.tagKey || itemKey },\n                  group,\n                },\n              }),\n              {}\n            ),\n          },\n        }),\n        {}\n      )\n    )\n  );\n};\n\nexport const generateFilter = async () => {\n  const searchParams = new URLSearchParams(location.hash?.substring(1));\n  const currToken = decodeToken(await insights.chrome.auth.getToken())?.session_state;\n  let data;\n  try {\n    data = JSON.parse(localStorage.getItem(`${GLOBAL_FILTER_KEY}/${currToken}`) || '{}');\n  } catch (e) {\n    data = {};\n  }\n\n  let { Workloads, [SID_KEY]: SIDs, ...tags } = data;\n\n  if (searchParams.get('workloads')) {\n    const { tag } = workloads[0].tags.find(({ tag: { key } }) => key === searchParams.get('workloads')) || {};\n    Workloads = tag?.key\n      ? {\n          [tag?.key]: {\n            group: omit(workloads[0], 'tags'),\n            isSelected: true,\n            item: { tagKey: tag?.key },\n          },\n        }\n      : data.Workloads;\n  }\n\n  if (typeof searchParams.get('tags') === 'string') {\n    tags = createTagsFilter(searchParams.get('tags')?.split(','));\n  }\n\n  if (typeof searchParams.get('SIDs') === 'string') {\n    SIDs = createTagsFilter(\n      searchParams\n        .get('SIDs')\n        ?.split(',')\n        .map((sid) => `${SID_KEY}/${sid}`)\n    )?.[SID_KEY];\n  }\n\n  return [\n    {\n      Workloads,\n      ...(SIDs && { [SID_KEY]: SIDs }),\n      ...tags,\n    },\n    currToken,\n  ];\n};\n\nexport const escaper = (value) => value.replace(/\\//gi, '%2F').replace(/=/gi, '%3D');\n\nexport const flatTags = memoize(\n  (filter, encode = false, format = false) => {\n    const { Workloads, [SID_KEY]: SID, ...tags } = filter;\n    const mappedTags = flatMap(Object.entries({ ...tags, ...(!format && { Workloads }) } || {}), ([namespace, item]) =>\n      Object.entries(item || {})\n        .filter(([, { isSelected }]) => isSelected)\n        .map(([tagKey, { item, value: tagValue }]) => {\n          return `${namespace ? `${encode ? encodeURIComponent(escaper(namespace)) : escaper(namespace)}/` : ''}${\n            encode ? encodeURIComponent(escaper(item?.tagKey || tagKey)) : escaper(item?.tagKey || tagKey)\n          }${\n            item?.tagValue || tagValue\n              ? `=${encode ? encodeURIComponent(escaper(item?.tagValue || tagValue)) : escaper(item?.tagValue || tagValue)}`\n              : ''\n          }`;\n        })\n    );\n    return format\n      ? [\n          Workloads,\n          Object.entries(SID || {})\n            .filter(([, { isSelected }]) => isSelected)\n            .reduce((acc, [key]) => [...acc, key], []),\n          mappedTags,\n        ]\n      : mappedTags;\n  },\n  (filter = {}, encode, format) =>\n    `${Object.entries(filter)\n      .map(\n        ([namespace, val]) =>\n          `${namespace}.${Object.entries(val || {})\n            .filter(([, { isSelected }]) => isSelected)\n            .map(([key]) => key)\n            .join('')}`\n      )\n      .join(',')}${encode ? '_encode' : ''}${format ? '_format' : ''}`\n);\n","import instance from '@redhat-cloud-services/frontend-components-utilities/interceptors';\nimport get from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\n\nconst obj = {\n  noAuthParam: 'noauth',\n  offlineToken: '2402500adeacc30eb5c5a8a5e2e0ec1f',\n  allowedUnauthedPaths: ['/', '/logout', '/beta', '/security/insights', '/beta/security/insights'],\n};\n\nconst matcherMapper = {\n  isEmpty,\n  isNotEmpty: (value) => !isEmpty(value),\n};\n/**\n * returns true/false if value matches required criteria. If invalid or no matcher is provided it returns the original value.\n * @param {any} value variable to be matched with matcher function\n * @param {string} matcher id of matcher\n */\nconst matchValue = (value, matcher) => {\n  const match = matcherMapper[matcher];\n  return typeof match === 'function' ? match(value) : value;\n};\n\n/**\n * Check if is permitted to see navigation link\n * @param {array} permissions array checked user permissions\n * @param {every|some} require type of permissions requirement\n * @returns {boolean}\n */\nconst checkPermissions = async (permissions = [], require = 'every') => {\n  const userPermissions = await insights.chrome.getUserPermissions();\n  return userPermissions && permissions[require]((item) => userPermissions.find(({ permission }) => permission === item));\n};\n\nexport const visibilityFunctions = {\n  isOrgAdmin: async () => {\n    const { identity } = await insights.chrome.auth.getUser();\n    try {\n      return identity.user.is_org_admin;\n    } catch {\n      return false;\n    }\n  },\n  isActive: async () => {\n    const { identity } = await insights.chrome.auth.getUser();\n    try {\n      return identity.user.is_active;\n    } catch {\n      return false;\n    }\n  },\n  isInternal: async () => {\n    const { identity } = await insights.chrome.auth.getUser();\n    try {\n      return identity.user.is_internal;\n    } catch {\n      return false;\n    }\n  },\n  isEntitled: async (appName) => {\n    const { entitlements } = await insights.chrome.auth.getUser();\n    return entitlements && appName\n      ? Boolean(entitlements[appName] && entitlements[appName].is_entitled)\n      : // eslint-disable-next-line camelcase\n        Object.entries(entitlements || {}).reduce((acc, [key, { is_entitled }]) => ({ ...acc, [key]: is_entitled }), {});\n  },\n  isProd: () => insights.chrome.isProd,\n  isBeta: () => insights.chrome.isBeta(),\n  loosePermissions: (permissions) => checkPermissions(permissions, 'some'),\n  hasPermissions: checkPermissions,\n  apiRequest: async ({ url, method, accessor, matcher, ...options }) => {\n    return instance({\n      url,\n      method: method || 'GET',\n      ...options,\n    })\n      .then((response) => matchValue(accessor ? get(response || {}, accessor) : response, matcher))\n      .catch((err) => {\n        console.log(err);\n        return false;\n      });\n  },\n};\n\nexport const isVisible = (limitedApps, app, visibility) => {\n  if (limitedApps && limitedApps.includes(app)) {\n    if (visibility instanceof Object) {\n      return Boolean(visibility[app]);\n    }\n\n    return visibility;\n  }\n\n  return true;\n};\n\nexport default Object.freeze(obj);\n","// Global Defaults\nexport const DEFAULT_ROUTES = {\n  prod: {\n    url: ['access.redhat.com', 'prod.foo.redhat.com', 'cloud.redhat.com'],\n    sso: 'https://sso.redhat.com/auth',\n  },\n  qa: {\n    url: ['qa.foo.redhat.com', 'qa.cloud.redhat.com'],\n    sso: 'https://sso.qa.redhat.com/auth',\n  },\n  ci: {\n    url: ['ci.foo.redhat.com', 'ci.cloud.redhat.com'],\n    sso: 'https://sso.qa.redhat.com/auth',\n  },\n  qaprodauth: {\n    url: ['qaprodauth.foo.redhat.com', 'qaprodauth.cloud.redhat.com'],\n    sso: 'https://sso.redhat.com/auth',\n  },\n  stage: {\n    url: ['cloud.stage.redhat.com'],\n    sso: 'https://sso.stage.redhat.com/auth',\n  },\n};\n\nexport const options = {\n  realm: 'redhat-external',\n  clientId: 'cloud-services',\n  cookieName: 'cs_jwt',\n};\n\nexport const noAuthParam = 'noauth';\n\nexport const offlineToken = '2402500adeacc30eb5c5a8a5e2e0ec1f';\n\nexport const allowedUnauthedPaths = ['/', '/logout', '/beta', '/security/insights', '/beta/security/insights'];\n","import axios from 'axios';\nimport { ServicesApi } from '@redhat-cloud-services/entitlements-client';\nimport { deleteLocalStorageItems, bootstrapCache, lastActive } from '../../utils';\n\nconst BASE_PATH = '/api/entitlements/v1';\n\nexport default (cachePrefix) => {\n  const cache = bootstrapCache(BASE_PATH, `${cachePrefix}-entitlements`);\n\n  const instance = axios.create({ adapter: cache.adapter });\n  instance.interceptors.response.use((response) => {\n    if (response && response.request && response.request.fromCache !== true) {\n      const last = lastActive('/api/entitlements/v1/services', 'fallback');\n      const keys = Object.keys(localStorage).filter((key) => key.endsWith('/api/entitlements/v1/services') && key !== last);\n\n      deleteLocalStorageItems(keys);\n    }\n\n    return response.data || response;\n  });\n  return new ServicesApi(undefined, BASE_PATH, instance);\n};\n","import consts from '../../consts';\nimport { DEFAULT_ROUTES } from '../constants';\nimport insightsUrl from './url';\nimport axios from 'axios';\nimport urijs from 'urijs';\n\nconst priv = {};\n// note this function is not exposed\n// it is a run everytime and produce some side affect thing\n// if a special condition is encountered\n//\n// it would be great to not have this behave this way\n// but the order that this needs to run in is very specific\n// so that is somewhat difficult\nexport function wipePostbackParamsThatAreNotForUs() {\n  if (getWindow().location.href.indexOf(consts.offlineToken) !== -1) {\n    // this is a UHC offline token postback\n    // we need to not let the JWT lib see this\n    // and try to use it\n    priv.postbackUrl = getWindow().location.href;\n\n    // we do this because keycloak.js looks at the hash for its parameters\n    // and if found uses the params for its own use\n    //\n    // in the UHC offline post back case we *dont*\n    // want the params to be used by keycloak.js\n    // so we have to destroy this stuff and let regular auth routines happen\n    getWindow().location.hash = '';\n\n    // nuke the params so that people dont see the ugly\n    const url = urijs(getWindow().location.href);\n    url.removeQuery(consts.noAuthParam);\n    getWindow().history.pushState('offlinePostback', '', url.toString());\n  }\n}\n\nexport function getOfflineToken(realm, clientId) {\n  const postbackUrl = getPostbackUrl();\n\n  if (!postbackUrl) {\n    // we need this postback URL because it contains parameters needed to\n    // call KC for the actual offline token\n    // thus we cant continue if it is missing\n    return Promise.reject('not available');\n  }\n\n  const tokenURL = `${insightsUrl(DEFAULT_ROUTES)}/realms/${realm}/protocol/openid-connect/token`;\n  const params = parseHashString(postbackUrl);\n\n  return axios({\n    method: 'post',\n    url: tokenURL,\n    data: getPostDataString(getPostDataObject(postbackUrl, clientId, params.code)),\n    config: { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } },\n  });\n}\n\nfunction getWindow() {\n  return window;\n}\n\nfunction getPostbackUrl() {\n  // let folks only do this once\n  const ret = priv.postbackUrl;\n  delete priv.postbackUrl;\n  return ret;\n}\n\nfunction getPostDataObject(url, clientId, code) {\n  return {\n    code: code,\n    grant_type: 'authorization_code', // eslint-disable-line camelcase\n    client_id: clientId, // eslint-disable-line camelcase\n    redirect_uri: encodeURIComponent(url.split('#')[0]), // eslint-disable-line camelcase\n  };\n}\n\nfunction parseHashString(str) {\n  return str\n    .split('#')[1]\n    .split('&')\n    .reduce((result, item) => {\n      const parts = item.split('=');\n      result[parts[0]] = parts[1];\n      return result;\n    }, {});\n}\n\nfunction getPostDataString(obj) {\n  return Object.entries(obj)\n    .map((entry) => {\n      return `${entry[0]}=${entry[1]}`;\n    })\n    .join('&');\n}\n","import logger from '../logger';\nconst log = logger('insights/url.js');\n\n// Parse through keycloak options routes\nexport default (env) => {\n  const ssoEnv = Object.entries(env).find(([, { url }]) => url.includes(location.hostname));\n\n  if (ssoEnv) {\n    log(`SSO Url: ${ssoEnv?.[1].sso}`);\n    log(`Current env: ${ssoEnv?.[0]}`);\n    return ssoEnv?.[1].sso;\n  } else {\n    log('SSO url: not found, defaulting to qa');\n    log('Current env: not found, defaultint to qa');\n    return 'https://sso.qa.redhat.com/auth';\n  }\n};\n","import { pageAllowsUnentitled, isValidAccountNumber } from '../../utils';\nimport servicesApi from './entitlements';\nimport logger from '../logger';\nconst log = logger('insights/user.js');\nconst pathMapper = {\n  'cost-management': 'cost_management',\n  insights: 'insights',\n  openshift: 'openshift',\n  migrations: 'migrations',\n  ansible: 'ansible',\n  subscriptions: 'subscriptions',\n  settings: 'settings',\n  'user-preferences': 'user_preferences',\n  internal: 'internal',\n};\n\nfunction getWindow() {\n  return window;\n}\n\n/* eslint-disable camelcase */\nfunction buildUser(token) {\n  const user = token\n    ? {\n        identity: {\n          account_number: token.account_number,\n          type: token.type,\n          user: {\n            username: token.username,\n            email: token.email,\n            first_name: token.first_name,\n            last_name: token.last_name,\n            is_active: token.is_active,\n            is_org_admin: token.is_org_admin,\n            is_internal: token.is_internal,\n            locale: token.locale,\n          },\n          internal: {\n            org_id: token.org_id,\n            account_id: token.account_id,\n          },\n        },\n      }\n    : null;\n\n  return user;\n}\n/* eslint-enable camelcase */\n\nfunction tryBounceIfUnentitled(data, section) {\n  // only test this on the apps that are in valid sections\n  // we need to keep /apps and other things functional\n  if (\n    section !== 'insights' &&\n    section !== 'openshift' &&\n    section !== 'cost-management' &&\n    section !== 'migrations' &&\n    section !== 'ansible' &&\n    section !== 'subscriptions' &&\n    section !== 'settings' &&\n    section !== 'user-preferences' &&\n    section !== 'internal'\n  ) {\n    return;\n  }\n\n  const service = pathMapper[section];\n  if (data === true) {\n    // this is a force bounce scenario!\n    getWindow().location.replace(`${document.baseURI}?not_entitled=${service}`);\n  }\n\n  if (section && section !== '') {\n    if (data?.[service]?.is_entitled) {\n      log(`Entitled to: ${service}`);\n    } else {\n      log(`Not entitled to: ${service}`);\n      getWindow().location.replace(`${document.baseURI}?not_entitled=${service}`);\n    }\n  }\n}\n\nexport default async (token) => {\n  let user = buildUser(token);\n\n  const pathName = getWindow().location.pathname.split('/');\n  pathName.shift();\n  if (pathName[0] === 'beta') {\n    pathName.shift();\n  }\n\n  if (user) {\n    log(`Account Number: ${user.identity.account_number}`);\n    let data;\n    try {\n      data = await servicesApi(token.jti).servicesGet();\n    } catch {\n      // let's swallow error from services API\n    }\n\n    // NOTE: Openshift supports Users with Account Number of -1\n    // thus we need to bypass here\n    // call entitlements on / /beta /openshift or /beta/openshift,\n    // but swallow error\n    //\n    // Landing Page *does* support accounts with -1\n    // it has to\n    if (pageAllowsUnentitled()) {\n      return {\n        ...user,\n        entitlements: data || {}, // if the services returned error, use empty object\n      };\n    }\n\n    // Important this has to come after the above -1 allow checks\n    // Otherwise we get bounced on those paths\n    //\n    // It also needs to not go int he servicesApi call\n    // because 3scale 403s if the Account number is -1\n    //\n    // we \"force\" a bounce here because the entitlements API\n    // was never called\n    if (!isValidAccountNumber(user.identity.account_number)) {\n      tryBounceIfUnentitled(true, pathName[0]);\n      return;\n    }\n\n    tryBounceIfUnentitled(data, pathName[0]);\n\n    return {\n      ...user,\n      entitlements: data,\n    };\n  } else {\n    log('User not ready');\n  }\n};\n","// Imports\nimport Keycloak from '@redhat-cloud-services/keycloak-js';\nimport { BroadcastChannel } from 'broadcast-channel';\nimport cookie from 'js-cookie';\nimport { pageRequiresAuthentication } from '../utils';\nimport * as Sentry from '@sentry/browser';\nimport { GLOBAL_FILTER_KEY } from '../App/GlobalFilter/constants';\nimport { deleteLocalStorageItems } from '../utils';\nimport logger from './logger';\n\n// Insights Specific\nimport insightsUrl from './insights/url';\nimport insightsUser from './insights/user';\nimport urijs from 'urijs';\nimport { DEFAULT_ROUTES, options as defaultOptions } from './constants';\n\nconst log = logger('jwt.js');\nconst DEFAULT_COOKIE_NAME = 'cs_jwt';\n\nconst priv = {};\n\n// Broadcast Channel\nconst authChannel = new BroadcastChannel('auth');\nauthChannel.onmessage = (e) => {\n  if (e && e.data && e.data.type) {\n    log(`BroadcastChannel, Received event : ${e.data.type}`);\n\n    switch (e.data.type) {\n      case 'logout':\n        return logout();\n      case 'login':\n        return login();\n      case 'refresh':\n        return updateToken();\n    }\n  }\n};\n\nexport function decodeToken(str) {\n  str = str.split('.')[1];\n  str = str.replace('/-/g', '+');\n  str = str.replace('/_/g', '/');\n  switch (str.length % 4) {\n    case 0:\n      break;\n    case 2:\n      str += '==';\n      break;\n    case 3:\n      str += '=';\n      break;\n    default:\n      throw 'Invalid token';\n  }\n\n  str = (str + '===').slice(0, str.length + (str.length % 4));\n  str = str.replace(/-/g, '+').replace(/_/g, '/');\n  str = decodeURIComponent(escape(atob(str)));\n  str = JSON.parse(str);\n\n  return str;\n}\n\nexport const doOffline = (key, val) => {\n  const url = urijs(window.location.href);\n  url.removeSearch(key);\n  url.addSearch(key, val);\n\n  const options = {\n    ...defaultOptions,\n    promiseType: 'native',\n    redirectUri: url.toString(),\n    url: insightsUrl(DEFAULT_ROUTES),\n  };\n\n  const kc = Keycloak(options);\n  kc.init(options).then(() => {\n    kc.login({\n      scope: 'offline_access',\n    });\n  });\n};\n\n/*** Initialization ***/\nexport const init = (options) => {\n  log('Initializing');\n\n  const cookieName = options.cookieName ? options.cookieName : DEFAULT_COOKIE_NAME;\n\n  priv.cookie = {\n    cookieName,\n  };\n  //constructor for new Keycloak Object?\n  options.url = insightsUrl(options.routes ? options.routes : DEFAULT_ROUTES);\n  options.clientId = 'cloud-services';\n  options.realm = 'redhat-external';\n\n  //options for keycloak.init method\n  options.promiseType = 'native';\n  options.onLoad = 'check-sso';\n  options.checkLoginIframe = false;\n\n  const isBeta = window.location.pathname.split('/')[1] === 'beta' ? '/beta' : '';\n\n  options.silentCheckSsoRedirectUri = `https://${window.location.host}${isBeta}/silent-check-sso.html`;\n\n  if (window.localStorage && window.localStorage.getItem('chrome:jwt:shortSession') === 'true') {\n    options.realm = 'short-session';\n  }\n\n  //priv.keycloak = Keycloak(options);\n  priv.keycloak = Keycloak(options);\n  priv.keycloak.onTokenExpired = updateToken;\n  priv.keycloak.onAuthSuccess = loginAllTabs;\n  priv.keycloak.onAuthRefreshSuccess = refreshTokens;\n\n  if (options.token) {\n    if (isExistingValid(options.token)) {\n      // we still need to init async\n      // so that the renewal times and such fire\n      priv.keycloak.init(options);\n\n      return new Promise((resolve) => {\n        // Here we have an existing key\n        // We need to set up some of the keycloak state\n        // so that the reset of the methods that Chrome uses\n        // to check if things are good get faked out\n        // TODO reafctor the direct access to priv.keycloak\n        // away from the users\n        priv.keycloak.authenticated = true;\n        priv.keycloak.token = options.token;\n        resolve();\n      });\n    } else {\n      delete options.token;\n    }\n  }\n\n  return priv.keycloak.init(options).then(initSuccess).catch(initError);\n};\n\nfunction isExistingValid(token) {\n  log('Checking validity of existing JWT');\n  try {\n    if (!token) {\n      return false;\n    }\n\n    const parsed = decodeToken(token);\n    if (!parsed.exp) {\n      return false;\n    }\n\n    // Date.now() has extra precision...\n    // it includes milis\n    // we need to trim it down to valid seconds from epoch\n    // because we compare to KC's exp which is seconds from epoch\n    const now = Date.now().toString().substr(0, 10);\n    const exp = parsed.exp - now;\n\n    log(`Token expires in ${exp}`);\n\n    // We want to invalidate tokens if they are getting close\n    // to the expiry time\n    // So that we can be someone safe from time skew\n    // issues on our APIs\n    // i.e. the client could have a slight time skew\n    // and the API is true (because NTP) and we could send down\n    // a JWT that is actually exipred\n    if (exp > 90) {\n      priv.keycloak.tokenParsed = parsed;\n      return true;\n    } else {\n      if (exp > 0) {\n        log('token is expiring in < 90 seconds');\n      } else {\n        log('token is expired');\n      }\n\n      return false;\n    }\n  } catch (e) {\n    log(e);\n    return false;\n  }\n}\n\n// keycloak init successful\nfunction initSuccess() {\n  log('JWT Initialized');\n  setCookie(priv.keycloak.token);\n  setRefresh(priv.keycloak.refreshToken);\n}\n\n// keycloak init failed\nfunction initError() {\n  log('JWT init error');\n  logout();\n}\n\n/*** Login/Logout ***/\nexport function login() {\n  log('Logging in');\n  // Redirect to login\n  cookie.set('cs_loggedOut', 'false');\n  return priv.keycloak.login({ redirectUri: location.href });\n}\n\nfunction logout(bounce) {\n  log('Logging out');\n\n  // Clear cookies and tokens\n  priv.keycloak.clearToken();\n  cookie.remove(priv.cookie.cookieName);\n  cookie.remove('cs_demo');\n\n  const isBeta = window.location.pathname.split('/')[1] === 'beta' ? '/beta' : '';\n  const keys = Object.keys(localStorage).filter(\n    (key) =>\n      key.endsWith('/api/entitlements/v1/services') ||\n      key.endsWith('/config/main.yml') ||\n      key.endsWith('/chrome') ||\n      key.endsWith('/chrome-store') ||\n      key.startsWith('kc-callback') ||\n      key.startsWith(GLOBAL_FILTER_KEY)\n  );\n  deleteLocalStorageItems(keys);\n  // Redirect to logout\n  if (bounce) {\n    let eightSeconds = new Date(new Date().getTime() + 8 * 1000);\n    cookie.set('cs_loggedOut', 'true', {\n      expires: eightSeconds,\n    });\n    priv.keycloak.logout({\n      redirectUri: `https://${window.location.host}${isBeta}`,\n    });\n  }\n}\n\nexport const logoutAllTabs = (bounce) => {\n  authChannel.postMessage({ type: 'logout' });\n  logout(bounce);\n};\n\nfunction loginAllTabs() {\n  authChannel.postMessage({ type: 'login' });\n}\n\n/*** User Functions ***/\n// Get user information\nexport const getUserInfo = () => {\n  log('Getting User Information');\n  const jwtCookie = cookie.get(DEFAULT_COOKIE_NAME);\n\n  if (jwtCookie && isExistingValid(jwtCookie) && isExistingValid(priv.keycloak.token)) {\n    return insightsUser(priv.keycloak.tokenParsed);\n  }\n\n  return updateToken()\n    .then(() => {\n      insightsUser(priv.keycloak.tokenParsed);\n      log('Successfully updated token');\n    })\n    .catch(() => {\n      if (pageRequiresAuthentication()) {\n        log('Trying to log in user to refresh token');\n        return login();\n      }\n    });\n};\n\n// Check to see if the user is loaded, this is what API calls should wait on\nexport const isAuthenticated = () => {\n  log(`User Ready: ${priv.keycloak.authenticated}`);\n  return priv.keycloak.authenticated;\n};\n\n/*** Check Token Status ***/\n// If a token is expired, logout of all tabs\nexport const expiredToken = () => {\n  log('Token has expired, trying to log out');\n  logout();\n};\n\n// Broadcast message to refresh tokens across tabs\nfunction refreshTokens() {\n  authChannel.postMessage({ type: 'refresh' });\n}\n\n// Actually update the token\nfunction updateToken() {\n  return priv.keycloak\n    .updateToken()\n    .then((refreshed) => {\n      // Important! after we update the token\n      // we have to again populate the Cookie!\n      // Otherwise we just update and dont send\n      // the updated token down stream... and things 401\n      setCookie(priv.keycloak.token);\n\n      log('Attempting to update token');\n\n      if (refreshed) {\n        log('Token was successfully refreshed');\n      } else {\n        log('Token is still valid, not updating');\n      }\n    })\n    .catch(() => {\n      /**\n       * The \"priv.keycloak.updateToken\" promise does not return any error message\n       */\n      log('Token update failed');\n    });\n}\n\nfunction getCookieExpires(exp) {\n  // we want the cookie to expire at the same time as the JWT session\n  // so we take the exp and get a new GTMString from that\n  const date = new Date(0);\n  date.setUTCSeconds(exp);\n  return date.toGMTString();\n}\n\n// Set the cookie for 3scale\nfunction setCookie(token) {\n  log('Setting the cs_jwt cookie');\n  if (token && token.length > 10) {\n    setCookieWrapper(`${priv.cookie.cookieName}=${token};` + `path=/;` + `secure=true;` + `expires=${getCookieExpires(decodeToken(token).exp)}`);\n  }\n}\n\nfunction setRefresh(refreshToken) {\n  log('Setting the refresh token');\n  cookie.set('cs_jwt_refresh', refreshToken, { secure: true });\n}\n\n// do this so we can mock out for test\nfunction setCookieWrapper(str) {\n  document.cookie = str;\n}\n\n// Encoded WIP\nexport const getEncodedToken = () => {\n  log('Trying to get the encoded token');\n\n  if (!isExistingValid(priv.keycloak.token)) {\n    Sentry.captureException(new Error('Fetching token failed - expired token'));\n    log('Failed to get encoded token');\n    updateToken();\n  }\n\n  return priv.keycloak.token;\n};\n\n// Keycloak server URL\nexport const getUrl = () => {\n  return insightsUrl(DEFAULT_ROUTES);\n};\n","// const pub = {};\n\nexport default (fileName) => {\n  return (msg) => {\n    if (window.console) {\n      if (window.localStorage && window.localStorage.getItem('chrome:jwt:debug')) {\n        window.console.log(`[JWT][${fileName}] ${msg}`);\n      }\n    }\n  };\n};\n","import { wipePostbackParamsThatAreNotForUs, getOfflineToken } from '../insights/offline';\n\nimport flatten from 'lodash/flatten';\n\nimport * as jwt from '../jwt';\nimport cookie from 'js-cookie';\nimport { options as defaultOptions, allowedUnauthedPaths } from '../constants';\nconst TIMER_STR = '[JWT][jwt.js] Auth time';\n\nfunction bouncer() {\n  if (allowUnauthed()) {\n    return;\n  }\n\n  if (!jwt.isAuthenticated()) {\n    cookie.remove(defaultOptions.cookieName);\n    jwt.login();\n  }\n\n  console.timeEnd(TIMER_STR); // eslint-disable-line no-console\n}\n\nfunction getAllowedUnauthedPaths() {\n  return flatten(allowedUnauthedPaths.map((e) => [e, e + '/']));\n}\n\nexport function allowUnauthed() {\n  if (getAllowedUnauthedPaths().includes(window.location.pathname)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport const initChromeAuth = () => {\n  console.time(TIMER_STR); // eslint-disable-line no-console\n  let options = {\n    ...defaultOptions,\n  };\n\n  wipePostbackParamsThatAreNotForUs();\n  const token = cookie.get(options.cookieName);\n\n  // If we find an existing token, use it\n  // so that we dont auth even when a valid token is present\n  // otherwise its quick, but we bounce around and get a new token\n  // on every page load\n  if (token && token.length > 10) {\n    options.token = token;\n    options.refreshToken = cookie.get('cs_jwt_refresh');\n  }\n\n  const promise = jwt.init(options).then(bouncer);\n\n  return {\n    initPromise: promise,\n  };\n};\n\nconst useChromeAuth = () => {\n  let options = {\n    ...defaultOptions,\n  };\n\n  return {\n    getOfflineToken: () => {\n      return getOfflineToken(options.realm, options.clientId);\n    },\n    ...jwt,\n  };\n};\n\nexport default useChromeAuth;\n","import groupBy from 'lodash/groupBy';\nexport const SID_KEY = 'SAP ID (SID)';\n\nexport const globalFilterDefaultState = {\n  scope: 'insights',\n  tags: { isLoaded: false, items: [], count: 0, total: 0 },\n  sid: { isLoaded: false, items: [], count: 0, total: 0 },\n  workloads: { isLoaded: false, items: [], count: 0, total: 0, hasSap: 0 },\n};\n\nexport function onGetAllTags(state, { payload }) {\n  return {\n    ...state,\n    tags: {\n      isLoaded: true,\n      items: Object.entries(groupBy(payload?.results || [], ({ tag: { namespace } }) => namespace)).map(([key, value]) => ({\n        name: key,\n        tags: value,\n      })),\n      total: payload?.total,\n      count: payload?.count,\n      page: payload?.page,\n      // eslint-disable-next-line camelcase\n      perPage: payload?.per_page,\n    },\n  };\n}\n\nexport function onGetAllTagsPending(state) {\n  return {\n    ...state,\n    tags: {\n      ...state.tags,\n      isLoaded: false,\n    },\n  };\n}\n\nexport function onSetGlobalFilterScope(state, { payload }) {\n  return {\n    ...state,\n    scope: payload,\n  };\n}\n\nexport function onGlobalFilterToggle(state, { payload }) {\n  return {\n    ...state,\n    globalFilterHidden: payload.isHidden,\n  };\n}\n\nexport function onTagSelect(state, { payload }) {\n  return {\n    ...state,\n    selectedTags: payload,\n  };\n}\n\nexport function onGetAllSIDs(state, { payload }) {\n  return {\n    ...state,\n    sid: {\n      isLoaded: true,\n      ...(payload?.total > 0 && {\n        items: [\n          {\n            name: SID_KEY,\n            tags: (payload?.results || []).map(({ value, count } = {}) => ({\n              tag: { key: value, namespace: SID_KEY },\n              count,\n            })),\n          },\n        ],\n      }),\n      total: payload?.total,\n      count: payload?.count,\n      page: payload?.page,\n      // eslint-disable-next-line camelcase\n      perPage: payload?.per_page,\n    },\n  };\n}\n\nexport function onGetAllSIDsPending(state) {\n  return {\n    ...state,\n    sid: {\n      ...state.sid,\n      isLoaded: false,\n    },\n  };\n}\n\nexport function onGetAllWorkloads(state, { payload }) {\n  const count = payload?.results?.find(({ value } = {}) => value)?.count || 0;\n  return {\n    ...state,\n    workloads: {\n      isLoaded: true,\n      count,\n      total: count,\n      hasSap: payload?.results?.find(({ value } = {}) => value)?.count || 0,\n    },\n  };\n}\n\nexport function onGetAllWorkloadsPending(state) {\n  return {\n    ...state,\n    workloads: {\n      ...state.workloads,\n      isLoaded: false,\n    },\n  };\n}\n\nexport function onGlobalFilterRemove(state, { payload }) {\n  return {\n    ...state,\n    globalFilterRemoved: payload.isHidden,\n  };\n}\n","import get from 'lodash/get';\nimport { setupCache } from 'axios-cache-adapter';\nimport { createCacheStore } from './utils/cache';\nimport { DEFAULT_ROUTES } from './jwt/constants';\n\nexport function getWindow() {\n  return window;\n}\n\n/* eslint-disable curly */\nexport function isValidAccountNumber(num) {\n  if (!num) return false;\n  if (num === -1) return false;\n  if (num === '-1') return false;\n  return Number.isInteger(Number(num));\n}\n/* eslint-enable curly */\n\nfunction getSection() {\n  const sections = getWindow().location.pathname.split('/');\n  if (sections[1] === 'beta') {\n    return sections[2] || '';\n  }\n\n  return sections[1];\n}\n\nexport function pageAllowsUnentitled() {\n  const pathname = getWindow().location.pathname;\n  if (\n    pathname === '/' ||\n    pathname === '/beta' ||\n    pathname === '/beta/' ||\n    pathname.indexOf('/openshift') === 0 ||\n    pathname.indexOf('/beta/openshift') === 0 ||\n    pathname.indexOf('/security') === 0 ||\n    pathname.indexOf('/beta/security') === 0\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function pageRequiresAuthentication() {\n  const section = getSection();\n  if (\n    section === 'insights' ||\n    section === 'cost-management' ||\n    section === 'apps' ||\n    section === 'ansible' ||\n    section === 'migrations' ||\n    section === 'subscriptions' ||\n    section === 'openshift' ||\n    section === 'settings' ||\n    section === 'user-preferences' ||\n    section === 'internal'\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Creates a redux listener that watches the state on given path (e.g. chrome.appNav) and calls\n * the given function when the state on the given path changes.\n *\n * The function is called with two parameters: current state value on the path, store reference\n */\nexport function createReduxListener(store, path, fn) {\n  let previous = undefined;\n\n  return () => {\n    const state = store.getState();\n    const current = get(state, path);\n\n    if (current !== previous) {\n      previous = current;\n      fn(current, store);\n    }\n  };\n}\n\nexport function deleteLocalStorageItems(keys) {\n  keys.map((key) => localStorage.removeItem(key));\n}\n\nexport function lastActive(searchString, fallback) {\n  return Object.keys(localStorage).reduce((acc, curr) => {\n    if (curr.includes(searchString)) {\n      try {\n        let accDate;\n        try {\n          accDate = new Date(JSON.parse(localStorage.getItem(acc).expires));\n        } catch {\n          accDate = new Date();\n        }\n\n        const currObj = JSON.parse(localStorage.getItem(curr));\n        return accDate >= new Date(currObj.expires) ? acc : curr;\n      } catch (e) {\n        return acc;\n      }\n    }\n\n    return acc;\n  }, fallback);\n}\n\nexport function bootstrapCache(endpoint, cacheKey) {\n  const store = createCacheStore(endpoint, cacheKey);\n  return setupCache({\n    store,\n    maxAge: 10 * 60 * 1000, // 10 minutes\n  });\n}\n\nexport function getUrl(type) {\n  if (window.location.pathname === ('/beta' || '/')) {\n    return 'landing';\n  }\n\n  const sections = window.location.pathname.split('/');\n  if (sections[1] === 'beta') {\n    return type === 'bundle' ? sections[2] : sections[3];\n  }\n\n  return type === 'bundle' ? sections[1] : sections[2];\n}\n\nexport function getEnv() {\n  return Object.entries(DEFAULT_ROUTES).find(([, { url }]) => url.includes(location.hostname))?.[0] || 'qa';\n}\n\nexport function isBeta() {\n  return window.location.pathname.split('/')[1] === 'beta' ? true : false;\n}\n\nexport function updateDocumentTitle(title) {\n  if (typeof title === 'undefined') {\n    return;\n  }\n  if (typeof title === 'string') {\n    document.title = title;\n  } else {\n    console.warn(`Title is not a string. Got ${typeof title} instead.`);\n  }\n}\n","import { lastActive, deleteLocalStorageItems } from '../utils';\n\nimport localforage from 'localforage';\n\nexport const createCacheStore = (endpoint, cacheKey) => {\n  const name = lastActive(endpoint, cacheKey);\n\n  return localforage.createInstance({\n    driver: [localforage.LOCALSTORAGE],\n    name: name?.split('/')[0] || name,\n  });\n};\n\nlet store;\n\n/**\n * Check if the app has switched between beta/non-beta envs.\n * If it did, we clean the existing chrome cache to prevent stale cache entry.\n * This issue may occur when the user switches between envs without logging out and in.\n */\nconst envSwap = () => {\n  const currentEnv = window.insights.chrome.isBeta() ? 'beta' : 'non-beta';\n  const prevEnv = localStorage.getItem('chrome:prevEnv');\n  if (prevEnv && currentEnv !== prevEnv) {\n    deleteLocalStorageItems(Object.keys(localStorage).filter((item) => item.endsWith('/chrome-store')));\n  }\n  localStorage.setItem('chrome:prevEnv', currentEnv);\n};\n\nexport class CacheAdapter {\n  constructor(endpoint, cacheKey, maxAge = 10 * 60 * 1000) {\n    this.maxAge = maxAge;\n    this.expires = new Date().getTime() + this.maxAge;\n    envSwap();\n    if (!store) {\n      const name = lastActive(endpoint, cacheKey);\n      let cached;\n      try {\n        cached = JSON.parse(localStorage.getItem(name));\n      } catch (e) {\n        cached = localStorage.getItem(name);\n      }\n      this.name = name;\n      this.endpoint = endpoint;\n      this.cacheKey = cacheKey;\n      store = createCacheStore(endpoint, cacheKey);\n      if (new Date(parseInt(cached?.expires, 10)) >= new Date()) {\n        this.setCache(parseInt(cached?.expires, 10), cached?.data);\n      } else {\n        const cacheTime = new Date().getTime() + this.maxAge;\n        this.setCache(cacheTime, {});\n      }\n    }\n  }\n\n  async setCache(expires, data) {\n    this.expires = expires;\n    await store.setItem(this.endpoint, {\n      data,\n      expires,\n    });\n  }\n\n  async invalidateStore() {\n    if (new Date(this.expires) <= new Date()) {\n      deleteLocalStorageItems(Object.keys(localStorage).filter((item) => item.endsWith('/chrome')));\n      await localforage.dropInstance();\n      store = createCacheStore(this.endpoint, this.cacheKey);\n      const cacheTime = new Date().getTime() + this.maxAge;\n      await this.setCache(cacheTime, {});\n    }\n  }\n\n  async setItem(key, data) {\n    await this.invalidateStore();\n    const cachedData = await store.getItem(this.endpoint);\n    cachedData.data = {\n      ...cachedData?.data,\n      [key]: data,\n    };\n    await store.setItem(this.endpoint, cachedData);\n  }\n\n  async getItem(key) {\n    await this.invalidateStore();\n    const cachedData = await store.getItem(this.endpoint);\n    return cachedData?.data?.[key];\n  }\n}\n"],"sourceRoot":""}