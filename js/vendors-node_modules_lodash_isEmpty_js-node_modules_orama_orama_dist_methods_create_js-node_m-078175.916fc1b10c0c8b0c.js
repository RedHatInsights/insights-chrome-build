(self["webpackChunkinsights_chrome"] = self["webpackChunkinsights_chrome"] || []).push([["vendors-node_modules_lodash_isEmpty_js-node_modules_orama_orama_dist_methods_create_js-node_m-078175"],{

/***/ "./node_modules/lodash/isEmpty.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isEmpty.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

module.exports = isEmpty;


/***/ }),

/***/ "./node_modules/@orama/orama/dist/components/algorithms.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@orama/orama/dist/components/algorithms.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BM25: () => (/* binding */ BM25),
/* harmony export */   prioritizeTokenScores: () => (/* binding */ prioritizeTokenScores)
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ "./node_modules/@orama/orama/dist/errors.js");

function prioritizeTokenScores(arrays, boost, threshold = 1, keywordsCount) {
    if (boost === 0) {
        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.createError)('INVALID_BOOST_VALUE');
    }
    const tokenScoresMap = new Map();
    const mapsLength = arrays.length;
    for(let i = 0; i < mapsLength; i++){
        const arr = arrays[i];
        const entriesLength = arr.length;
        for(let j = 0; j < entriesLength; j++){
            var _tokenScoresMap_get;
            const [token, score] = arr[j];
            const boostScore = score * boost;
            const oldScore = (_tokenScoresMap_get = tokenScoresMap.get(token)) === null || _tokenScoresMap_get === void 0 ? void 0 : _tokenScoresMap_get[0];
            if (oldScore !== undefined) {
                var _tokenScoresMap_get1;
                tokenScoresMap.set(token, [
                    oldScore * 1.5 + boostScore,
                    (((_tokenScoresMap_get1 = tokenScoresMap === null || tokenScoresMap === void 0 ? void 0 : tokenScoresMap.get(token)) === null || _tokenScoresMap_get1 === void 0 ? void 0 : _tokenScoresMap_get1[1]) || 0) + 1
                ]);
            } else {
                tokenScoresMap.set(token, [
                    boostScore,
                    1
                ]);
            }
        }
    }
    const tokenScores = [];
    for (const tokenScoreEntry of tokenScoresMap.entries()){
        tokenScores.push([
            tokenScoreEntry[0],
            tokenScoreEntry[1][0]
        ]);
    }
    const results = tokenScores.sort((a, b)=>b[1] - a[1]);
    // If threshold is 1, it means we will return all the results with at least one search term,
    // prioritizig the ones that contains more search terms (fuzzy match)
    if (threshold === 1) {
        return results;
    }
    // Prepare keywords count tracking for threshold handling
    const allResults = results.length;
    const tokenScoreWithKeywordsCount = [];
    for (const tokenScoreEntry of tokenScoresMap.entries()){
        tokenScoreWithKeywordsCount.push([
            tokenScoreEntry[0],
            tokenScoreEntry[1][0],
            tokenScoreEntry[1][1]
        ]);
    }
    // Find the index of the last result with all keywords.
    // Order the documents by the number of keywords they contain, and then by the score.
    const keywordsPerToken = tokenScoreWithKeywordsCount.sort((a, b)=>{
        // Compare by the third element, higher numbers first
        if (a[2] > b[2]) return -1;
        if (a[2] < b[2]) return 1;
        // If the third elements are equal, compare by the second element, higher numbers first
        if (a[1] > b[1]) return -1;
        if (a[1] < b[1]) return 1;
        // If both the second and third elements are equal, consider the elements equal
        return 0;
    });
    let lastTokenWithAllKeywords = undefined;
    for(let i = 0; i < allResults; i++){
        if (keywordsPerToken[i][2] === keywordsCount) {
            lastTokenWithAllKeywords = i;
        } else {
            break;
        }
    }
    // If no results had all the keywords, either bail out earlier or normalize
    if (typeof lastTokenWithAllKeywords === 'undefined') {
        if (threshold === 0) {
            return [];
        }
        lastTokenWithAllKeywords = 0;
    }
    const keywordsPerTokenLength = keywordsPerToken.length;
    const resultsWithIdAndScore = new Array(keywordsPerTokenLength);
    for(let i = 0; i < keywordsPerTokenLength; i++){
        resultsWithIdAndScore[i] = [
            keywordsPerToken[i][0],
            keywordsPerToken[i][1]
        ];
    }
    // If threshold is 0, it means we will only return all the results that contains ALL the search terms (exact match)
    if (threshold === 0) {
        return resultsWithIdAndScore.slice(0, lastTokenWithAllKeywords + 1);
    }
    // If the threshold is between 0 and 1, we will return all the results that contains at least the threshold of search terms
    // For example, if threshold is 0.5, we will return all the results that contains at least 50% of the search terms
    // (fuzzy match with a minimum threshold)
    const thresholdLength = lastTokenWithAllKeywords + Math.ceil(threshold * 100 * (allResults - lastTokenWithAllKeywords) / 100);
    return resultsWithIdAndScore.slice(0, allResults + thresholdLength);
}
function BM25(tf, matchingCount, docsCount, fieldLength, averageFieldLength, { k , b , d  }) {
    const idf = Math.log(1 + (docsCount - matchingCount + 0.5) / (matchingCount + 0.5));
    return idf * (d + tf * (k + 1)) / (tf + k * (1 - b + b * fieldLength / averageFieldLength));
}

//# sourceMappingURL=algorithms.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/components/cosine-similarity.js":
/*!************************************************************************!*\
  !*** ./node_modules/@orama/orama/dist/components/cosine-similarity.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   findSimilarVectors: () => (/* binding */ findSimilarVectors),
/* harmony export */   getMagnitude: () => (/* binding */ getMagnitude)
/* harmony export */ });
function getMagnitude(vector, vectorLength) {
    let magnitude = 0;
    for(let i = 0; i < vectorLength; i++){
        magnitude += vector[i] * vector[i];
    }
    return Math.sqrt(magnitude);
}
// @todo: Write plugins for Node and Browsers to use parallel computation for this function
function findSimilarVectors(targetVector, vectors, length, threshold = 0.8) {
    const targetMagnitude = getMagnitude(targetVector, length);
    const similarVectors = [];
    for (const [vectorId, [magnitude, vector]] of Object.entries(vectors)){
        let dotProduct = 0;
        for(let i = 0; i < length; i++){
            dotProduct += targetVector[i] * vector[i];
        }
        const similarity = dotProduct / (targetMagnitude * magnitude);
        if (similarity >= threshold) {
            similarVectors.push([
                vectorId,
                similarity
            ]);
        }
    }
    return similarVectors.sort((a, b)=>b[1] - a[1]);
}

//# sourceMappingURL=cosine-similarity.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/components/defaults.js":
/*!***************************************************************!*\
  !*** ./node_modules/@orama/orama/dist/components/defaults.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   formatElapsedTime: () => (/* binding */ formatElapsedTime),
/* harmony export */   getDocumentIndexId: () => (/* binding */ getDocumentIndexId),
/* harmony export */   getDocumentProperties: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.getDocumentProperties),
/* harmony export */   getInnerType: () => (/* binding */ getInnerType),
/* harmony export */   getVectorSize: () => (/* binding */ getVectorSize),
/* harmony export */   isArrayType: () => (/* binding */ isArrayType),
/* harmony export */   isGeoPointType: () => (/* binding */ isGeoPointType),
/* harmony export */   isVectorType: () => (/* binding */ isVectorType),
/* harmony export */   validateSchema: () => (/* binding */ validateSchema)
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors.js */ "./node_modules/@orama/orama/dist/errors.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/@orama/orama/dist/utils.js");



async function formatElapsedTime(n) {
    return {
        raw: Number(n),
        formatted: await (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.formatNanoseconds)(n)
    };
}
async function getDocumentIndexId(doc) {
    if (doc.id) {
        if (typeof doc.id !== 'string') {
            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_1__.createError)('DOCUMENT_ID_MUST_BE_STRING', typeof doc.id);
        }
        return doc.id;
    }
    return await (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.uniqueId)();
}
async function validateSchema(doc, schema) {
    for (const [prop, type] of Object.entries(schema)){
        const value = doc[prop];
        if (typeof value === 'undefined') {
            continue;
        }
        if (type === 'geopoint' && typeof value === 'object' && typeof value.lon === 'number' && typeof value.lat === 'number') {
            continue;
        }
        if (type === 'enum' && (typeof value === 'string' || typeof value === 'number')) {
            continue;
        }
        if (type === 'enum[]' && Array.isArray(value)) {
            const valueLength = value.length;
            for(let i = 0; i < valueLength; i++){
                if (typeof value[i] !== 'string' && typeof value[i] !== 'number') {
                    return prop + '.' + i;
                }
            }
            continue;
        }
        if (isVectorType(type)) {
            const vectorSize = getVectorSize(type);
            if (!Array.isArray(value) || value.length !== vectorSize) {
                throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_1__.createError)('INVALID_INPUT_VECTOR', prop, vectorSize, value.length);
            }
            continue;
        }
        if (isArrayType(type)) {
            if (!Array.isArray(value)) {
                return prop;
            }
            const expectedType = getInnerType(type);
            const valueLength = value.length;
            for(let i = 0; i < valueLength; i++){
                if (typeof value[i] !== expectedType) {
                    return prop + '.' + i;
                }
            }
            continue;
        }
        if (typeof type === 'object') {
            if (!value || typeof value !== 'object') {
                return prop;
            }
            // using as ResultDocument is not exactly right but trying to be type-safe here is not useful
            const subProp = await validateSchema(value, type);
            if (subProp) {
                return prop + '.' + subProp;
            }
            continue;
        }
        if (typeof value !== type) {
            return prop;
        }
    }
    return undefined;
}
const IS_ARRAY_TYPE = {
    string: false,
    number: false,
    boolean: false,
    enum: false,
    geopoint: false,
    'string[]': true,
    'number[]': true,
    'boolean[]': true,
    'enum[]': true
};
const INNER_TYPE = {
    'string[]': 'string',
    'number[]': 'number',
    'boolean[]': 'boolean',
    'enum[]': 'enum'
};
function isGeoPointType(type) {
    return type === 'geopoint';
}
function isVectorType(type) {
    return typeof type === 'string' && /^vector\[\d+\]$/.test(type);
}
function isArrayType(type) {
    return typeof type === 'string' && IS_ARRAY_TYPE[type];
}
function getInnerType(type) {
    return INNER_TYPE[type];
}
function getVectorSize(type) {
    const size = Number(type.slice(7, -1));
    switch(true){
        case isNaN(size):
            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_1__.createError)('INVALID_VECTOR_VALUE', type);
        case size <= 0:
            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_1__.createError)('INVALID_VECTOR_SIZE', type);
        default:
            return size;
    }
}

//# sourceMappingURL=defaults.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/components/documents-store.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@orama/orama/dist/components/documents-store.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   count: () => (/* binding */ count),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   createDocumentsStore: () => (/* binding */ createDocumentsStore),
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   getAll: () => (/* binding */ getAll),
/* harmony export */   getMultiple: () => (/* binding */ getMultiple),
/* harmony export */   load: () => (/* binding */ load),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   save: () => (/* binding */ save),
/* harmony export */   store: () => (/* binding */ store)
/* harmony export */ });
/* harmony import */ var _internal_document_id_store_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal-document-id-store.js */ "./node_modules/@orama/orama/dist/components/internal-document-id-store.js");

async function create(_, sharedInternalDocumentStore) {
    return {
        sharedInternalDocumentStore,
        docs: {},
        count: 0
    };
}
async function get(store, id) {
    const internalId = (0,_internal_document_id_store_js__WEBPACK_IMPORTED_MODULE_0__.getInternalDocumentId)(store.sharedInternalDocumentStore, id);
    return store.docs[internalId];
}
async function getMultiple(store, ids) {
    const idsLength = ids.length;
    const found = Array.from({
        length: idsLength
    });
    for(let i = 0; i < idsLength; i++){
        const internalId = (0,_internal_document_id_store_js__WEBPACK_IMPORTED_MODULE_0__.getInternalDocumentId)(store.sharedInternalDocumentStore, ids[i]);
        found[i] = store.docs[internalId];
    }
    return found;
}
async function getAll(store) {
    return store.docs;
}
async function store(store, id, doc) {
    const internalId = (0,_internal_document_id_store_js__WEBPACK_IMPORTED_MODULE_0__.getInternalDocumentId)(store.sharedInternalDocumentStore, id);
    if (typeof store.docs[internalId] !== 'undefined') {
        return false;
    }
    store.docs[internalId] = doc;
    store.count++;
    return true;
}
async function remove(store, id) {
    const internalId = (0,_internal_document_id_store_js__WEBPACK_IMPORTED_MODULE_0__.getInternalDocumentId)(store.sharedInternalDocumentStore, id);
    if (typeof store.docs[internalId] === 'undefined') {
        return false;
    }
    delete store.docs[internalId];
    store.count--;
    return true;
}
async function count(store) {
    return store.count;
}
async function load(sharedInternalDocumentStore, raw) {
    const rawDocument = raw;
    return {
        docs: rawDocument.docs,
        count: rawDocument.count,
        sharedInternalDocumentStore
    };
}
async function save(store) {
    return {
        docs: store.docs,
        count: store.count
    };
}
async function createDocumentsStore() {
    return {
        create,
        get,
        getMultiple,
        getAll,
        store,
        remove,
        count,
        load,
        save
    };
}

//# sourceMappingURL=documents-store.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/components/hooks.js":
/*!************************************************************!*\
  !*** ./node_modules/@orama/orama/dist/components/hooks.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FUNCTION_COMPONENTS: () => (/* binding */ FUNCTION_COMPONENTS),
/* harmony export */   OBJECT_COMPONENTS: () => (/* binding */ OBJECT_COMPONENTS),
/* harmony export */   SINGLE_OR_ARRAY_COMPONENTS: () => (/* binding */ SINGLE_OR_ARRAY_COMPONENTS),
/* harmony export */   runAfterCreate: () => (/* binding */ runAfterCreate),
/* harmony export */   runAfterSearch: () => (/* binding */ runAfterSearch),
/* harmony export */   runBeforeSearch: () => (/* binding */ runBeforeSearch),
/* harmony export */   runMultipleHook: () => (/* binding */ runMultipleHook),
/* harmony export */   runSingleHook: () => (/* binding */ runSingleHook)
/* harmony export */ });
const OBJECT_COMPONENTS = [
    'tokenizer',
    'index',
    'documentsStore',
    'sorter'
];
const FUNCTION_COMPONENTS = [
    'validateSchema',
    'getDocumentIndexId',
    'getDocumentProperties',
    'formatElapsedTime'
];
const SINGLE_OR_ARRAY_COMPONENTS = [];
async function runSingleHook(hooks, orama, id, doc) {
    const hooksLength = hooks.length;
    for(let i = 0; i < hooksLength; i++){
        await hooks[i](orama, id, doc);
    }
}
async function runMultipleHook(hooks, orama, docsOrIds) {
    const hooksLength = hooks.length;
    for(let i = 0; i < hooksLength; i++){
        await hooks[i](orama, docsOrIds);
    }
}
async function runAfterSearch(hooks, db, params, language, results) {
    const hooksLength = hooks.length;
    for(let i = 0; i < hooksLength; i++){
        await hooks[i](db, params, language, results);
    }
}
async function runBeforeSearch(hooks, db, params, language) {
    const hooksLength = hooks.length;
    for(let i = 0; i < hooksLength; i++){
        await hooks[i](db, params, language);
    }
}
async function runAfterCreate(hooks, db) {
    const hooksLength = hooks.length;
    for(let i = 0; i < hooksLength; i++){
        await hooks[i](db);
    }
}

//# sourceMappingURL=hooks.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/components/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@orama/orama/dist/components/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calculateResultScores: () => (/* binding */ calculateResultScores),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   createIndex: () => (/* binding */ createIndex),
/* harmony export */   getSearchableProperties: () => (/* binding */ getSearchableProperties),
/* harmony export */   getSearchablePropertiesWithTypes: () => (/* binding */ getSearchablePropertiesWithTypes),
/* harmony export */   insert: () => (/* binding */ insert),
/* harmony export */   insertDocumentScoreParameters: () => (/* binding */ insertDocumentScoreParameters),
/* harmony export */   insertTokenScoreParameters: () => (/* binding */ insertTokenScoreParameters),
/* harmony export */   load: () => (/* binding */ load),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   removeDocumentScoreParameters: () => (/* binding */ removeDocumentScoreParameters),
/* harmony export */   removeTokenScoreParameters: () => (/* binding */ removeTokenScoreParameters),
/* harmony export */   save: () => (/* binding */ save),
/* harmony export */   search: () => (/* binding */ search),
/* harmony export */   searchByWhereClause: () => (/* binding */ searchByWhereClause)
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../errors.js */ "./node_modules/@orama/orama/dist/errors.js");
/* harmony import */ var _trees_avl_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../trees/avl.js */ "./node_modules/@orama/orama/dist/trees/avl.js");
/* harmony import */ var _trees_flat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../trees/flat.js */ "./node_modules/@orama/orama/dist/trees/flat.js");
/* harmony import */ var _trees_radix_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../trees/radix.js */ "./node_modules/@orama/orama/dist/trees/radix.js");
/* harmony import */ var _trees_bkd_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../trees/bkd.js */ "./node_modules/@orama/orama/dist/trees/bkd.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils.js */ "./node_modules/@orama/orama/dist/utils.js");
/* harmony import */ var _algorithms_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./algorithms.js */ "./node_modules/@orama/orama/dist/components/algorithms.js");
/* harmony import */ var _cosine_similarity_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cosine-similarity.js */ "./node_modules/@orama/orama/dist/components/cosine-similarity.js");
/* harmony import */ var _defaults_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./defaults.js */ "./node_modules/@orama/orama/dist/components/defaults.js");
/* harmony import */ var _internal_document_id_store_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal-document-id-store.js */ "./node_modules/@orama/orama/dist/components/internal-document-id-store.js");










async function insertDocumentScoreParameters(index, prop, id, tokens, docsCount) {
    const internalId = (0,_internal_document_id_store_js__WEBPACK_IMPORTED_MODULE_0__.getInternalDocumentId)(index.sharedInternalDocumentStore, id);
    index.avgFieldLength[prop] = ((index.avgFieldLength[prop] ?? 0) * (docsCount - 1) + tokens.length) / docsCount;
    index.fieldLengths[prop][internalId] = tokens.length;
    index.frequencies[prop][internalId] = {};
}
async function insertTokenScoreParameters(index, prop, id, tokens, token) {
    let tokenFrequency = 0;
    for (const t of tokens){
        if (t === token) {
            tokenFrequency++;
        }
    }
    const internalId = (0,_internal_document_id_store_js__WEBPACK_IMPORTED_MODULE_0__.getInternalDocumentId)(index.sharedInternalDocumentStore, id);
    const tf = tokenFrequency / tokens.length;
    index.frequencies[prop][internalId][token] = tf;
    if (!(token in index.tokenOccurrences[prop])) {
        index.tokenOccurrences[prop][token] = 0;
    }
    // increase a token counter that may not yet exist
    index.tokenOccurrences[prop][token] = (index.tokenOccurrences[prop][token] ?? 0) + 1;
}
async function removeDocumentScoreParameters(index, prop, id, docsCount) {
    const internalId = (0,_internal_document_id_store_js__WEBPACK_IMPORTED_MODULE_0__.getInternalDocumentId)(index.sharedInternalDocumentStore, id);
    index.avgFieldLength[prop] = (index.avgFieldLength[prop] * docsCount - index.fieldLengths[prop][internalId]) / (docsCount - 1);
    index.fieldLengths[prop][internalId] = undefined;
    index.frequencies[prop][internalId] = undefined;
}
async function removeTokenScoreParameters(index, prop, token) {
    index.tokenOccurrences[prop][token]--;
}
async function calculateResultScores(context, index, prop, term, ids) {
    const documentIDs = Array.from(ids);
    // Exact fields for TF-IDF
    const avgFieldLength = index.avgFieldLength[prop];
    const fieldLengths = index.fieldLengths[prop];
    const oramaOccurrences = index.tokenOccurrences[prop];
    const oramaFrequencies = index.frequencies[prop];
    // oramaOccurrences[term] can be undefined, 0, string, or { [k: string]: number }
    const termOccurrences = typeof oramaOccurrences[term] === 'number' ? oramaOccurrences[term] ?? 0 : 0;
    const scoreList = [];
    // Calculate TF-IDF value for each term, in each document, for each index.
    const documentIDsLength = documentIDs.length;
    for(let k = 0; k < documentIDsLength; k++){
        var _oramaFrequencies_internalId;
        const internalId = (0,_internal_document_id_store_js__WEBPACK_IMPORTED_MODULE_0__.getInternalDocumentId)(index.sharedInternalDocumentStore, documentIDs[k]);
        const tf = (oramaFrequencies === null || oramaFrequencies === void 0 ? void 0 : (_oramaFrequencies_internalId = oramaFrequencies[internalId]) === null || _oramaFrequencies_internalId === void 0 ? void 0 : _oramaFrequencies_internalId[term]) ?? 0;
        const bm25 = (0,_algorithms_js__WEBPACK_IMPORTED_MODULE_1__.BM25)(tf, termOccurrences, context.docsCount, fieldLengths[internalId], avgFieldLength, context.params.relevance);
        scoreList.push([
            internalId,
            bm25
        ]);
    }
    return scoreList;
}
async function create(orama, sharedInternalDocumentStore, schema, index, prefix = '') {
    if (!index) {
        index = {
            sharedInternalDocumentStore,
            indexes: {},
            vectorIndexes: {},
            searchableProperties: [],
            searchablePropertiesWithTypes: {},
            frequencies: {},
            tokenOccurrences: {},
            avgFieldLength: {},
            fieldLengths: {}
        };
    }
    for (const [prop, type] of Object.entries(schema)){
        const path = `${prefix}${prefix ? '.' : ''}${prop}`;
        if (typeof type === 'object' && !Array.isArray(type)) {
            // Nested
            create(orama, sharedInternalDocumentStore, type, index, path);
            continue;
        }
        if ((0,_defaults_js__WEBPACK_IMPORTED_MODULE_2__.isVectorType)(type)) {
            index.searchableProperties.push(path);
            index.searchablePropertiesWithTypes[path] = type;
            index.vectorIndexes[path] = {
                size: (0,_defaults_js__WEBPACK_IMPORTED_MODULE_2__.getVectorSize)(type),
                vectors: {}
            };
        } else {
            const isArray = /\[/.test(type);
            switch(type){
                case 'boolean':
                case 'boolean[]':
                    index.indexes[path] = {
                        type: 'Bool',
                        node: {
                            true: [],
                            false: []
                        },
                        isArray
                    };
                    break;
                case 'number':
                case 'number[]':
                    index.indexes[path] = {
                        type: 'AVL',
                        node: (0,_trees_avl_js__WEBPACK_IMPORTED_MODULE_3__.create)(0, []),
                        isArray
                    };
                    break;
                case 'string':
                case 'string[]':
                    index.indexes[path] = {
                        type: 'Radix',
                        node: (0,_trees_radix_js__WEBPACK_IMPORTED_MODULE_4__.create)(),
                        isArray
                    };
                    index.avgFieldLength[path] = 0;
                    index.frequencies[path] = {};
                    index.tokenOccurrences[path] = {};
                    index.fieldLengths[path] = {};
                    break;
                case 'enum':
                case 'enum[]':
                    index.indexes[path] = {
                        type: 'Flat',
                        node: (0,_trees_flat_js__WEBPACK_IMPORTED_MODULE_5__.create)(),
                        isArray
                    };
                    break;
                case 'geopoint':
                    index.indexes[path] = {
                        type: 'BKD',
                        node: (0,_trees_bkd_js__WEBPACK_IMPORTED_MODULE_6__.create)(),
                        isArray
                    };
                    break;
                default:
                    throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_7__.createError)('INVALID_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path);
            }
            index.searchableProperties.push(path);
            index.searchablePropertiesWithTypes[path] = type;
        }
    }
    return index;
}
function insertScalarBuilder(implementation, index, prop, id, language, tokenizer, docsCount) {
    return async (value)=>{
        const internalId = (0,_internal_document_id_store_js__WEBPACK_IMPORTED_MODULE_0__.getInternalDocumentId)(index.sharedInternalDocumentStore, id);
        const { type , node  } = index.indexes[prop];
        switch(type){
            case 'Bool':
                {
                    node[value ? 'true' : 'false'].push(internalId);
                    break;
                }
            case 'AVL':
                {
                    (0,_trees_avl_js__WEBPACK_IMPORTED_MODULE_3__.insert)(node, value, [
                        internalId
                    ]);
                    break;
                }
            case 'Radix':
                {
                    const tokens = await tokenizer.tokenize(value, language, prop);
                    await implementation.insertDocumentScoreParameters(index, prop, internalId, tokens, docsCount);
                    for (const token of tokens){
                        await implementation.insertTokenScoreParameters(index, prop, internalId, tokens, token);
                        (0,_trees_radix_js__WEBPACK_IMPORTED_MODULE_4__.insert)(node, token, internalId);
                    }
                    break;
                }
            case 'Flat':
                {
                    (0,_trees_flat_js__WEBPACK_IMPORTED_MODULE_5__.insert)(node, value, internalId);
                    break;
                }
            case 'BKD':
                {
                    (0,_trees_bkd_js__WEBPACK_IMPORTED_MODULE_6__.insert)(node, value, [
                        internalId
                    ]);
                    break;
                }
        }
    };
}
async function insert(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {
    if ((0,_defaults_js__WEBPACK_IMPORTED_MODULE_2__.isVectorType)(schemaType)) {
        return insertVector(index, prop, value, id);
    }
    const insertScalar = insertScalarBuilder(implementation, index, prop, id, language, tokenizer, docsCount);
    if (!(0,_defaults_js__WEBPACK_IMPORTED_MODULE_2__.isArrayType)(schemaType)) {
        return insertScalar(value);
    }
    const elements = value;
    const elementsLength = elements.length;
    for(let i = 0; i < elementsLength; i++){
        await insertScalar(elements[i]);
    }
}
function insertVector(index, prop, value, id) {
    if (!(value instanceof Float32Array)) {
        value = new Float32Array(value);
    }
    const size = index.vectorIndexes[prop].size;
    const magnitude = (0,_cosine_similarity_js__WEBPACK_IMPORTED_MODULE_8__.getMagnitude)(value, size);
    index.vectorIndexes[prop].vectors[id] = [
        magnitude,
        value
    ];
}
async function removeScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {
    const internalId = (0,_internal_document_id_store_js__WEBPACK_IMPORTED_MODULE_0__.getInternalDocumentId)(index.sharedInternalDocumentStore, id);
    if ((0,_defaults_js__WEBPACK_IMPORTED_MODULE_2__.isVectorType)(schemaType)) {
        delete index.vectorIndexes[prop].vectors[id];
        return true;
    }
    const { type , node  } = index.indexes[prop];
    switch(type){
        case 'AVL':
            {
                (0,_trees_avl_js__WEBPACK_IMPORTED_MODULE_3__.removeDocument)(node, internalId, value);
                return true;
            }
        case 'Bool':
            {
                const booleanKey = value ? 'true' : 'false';
                const position = node[booleanKey].indexOf(internalId);
                node[value ? 'true' : 'false'].splice(position, 1);
                return true;
            }
        case 'Radix':
            {
                const tokens = await tokenizer.tokenize(value, language, prop);
                await implementation.removeDocumentScoreParameters(index, prop, id, docsCount);
                for (const token of tokens){
                    await implementation.removeTokenScoreParameters(index, prop, token);
                    (0,_trees_radix_js__WEBPACK_IMPORTED_MODULE_4__.removeDocumentByWord)(node, token, internalId);
                }
                return true;
            }
        case 'Flat':
            {
                (0,_trees_flat_js__WEBPACK_IMPORTED_MODULE_5__.removeDocument)(node, internalId, value);
                return true;
            }
        case 'BKD':
            {
                (0,_trees_bkd_js__WEBPACK_IMPORTED_MODULE_6__.removeDocByID)(node, value, internalId);
                return false;
            }
    }
}
async function remove(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount) {
    if (!(0,_defaults_js__WEBPACK_IMPORTED_MODULE_2__.isArrayType)(schemaType)) {
        return removeScalar(implementation, index, prop, id, value, schemaType, language, tokenizer, docsCount);
    }
    const innerSchemaType = (0,_defaults_js__WEBPACK_IMPORTED_MODULE_2__.getInnerType)(schemaType);
    const elements = value;
    const elementsLength = elements.length;
    for(let i = 0; i < elementsLength; i++){
        await removeScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount);
    }
    return true;
}
async function search(context, index, prop, term) {
    if (!(prop in index.tokenOccurrences)) {
        return [];
    }
    const { node , type  } = index.indexes[prop];
    if (type !== 'Radix') {
        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_7__.createError)('WRONG_SEARCH_PROPERTY_TYPE', prop);
    }
    const { exact , tolerance  } = context.params;
    const searchResult = (0,_trees_radix_js__WEBPACK_IMPORTED_MODULE_4__.find)(node, {
        term,
        exact,
        tolerance
    });
    const ids = new Set();
    for(const key in searchResult){
        //skip keys inherited from prototype
        const ownProperty = (0,_utils_js__WEBPACK_IMPORTED_MODULE_9__.getOwnProperty)(searchResult, key);
        if (!ownProperty) continue;
        for (const id of searchResult[key]){
            ids.add(id);
        }
    }
    return context.index.calculateResultScores(context, index, prop, term, Array.from(ids));
}
async function searchByWhereClause(context, index, filters) {
    const filterKeys = Object.keys(filters);
    const filtersMap = filterKeys.reduce((acc, key)=>({
            [key]: [],
            ...acc
        }), {});
    for (const param of filterKeys){
        const operation = filters[param];
        if (typeof index.indexes[param] === 'undefined') {
            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_7__.createError)('UNKNOWN_FILTER_PROPERTY', param);
        }
        const { node , type , isArray  } = index.indexes[param];
        if (type === 'Bool') {
            const idx = node;
            const filteredIDs = idx[operation.toString()];
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_9__.safeArrayPush)(filtersMap[param], filteredIDs);
            continue;
        }
        if (type === 'BKD') {
            let reqOperation;
            if ('radius' in operation) {
                reqOperation = 'radius';
            } else if ('polygon' in operation) {
                reqOperation = 'polygon';
            } else {
                throw new Error(`Invalid operation ${operation}`);
            }
            if (reqOperation === 'radius') {
                const { value , coordinates , unit ='m' , inside =true , highPrecision =false  } = operation[reqOperation];
                const distanceInMeters = (0,_utils_js__WEBPACK_IMPORTED_MODULE_9__.convertDistanceToMeters)(value, unit);
                const ids = (0,_trees_bkd_js__WEBPACK_IMPORTED_MODULE_6__.searchByRadius)(node.root, coordinates, distanceInMeters, inside, undefined, highPrecision);
                // @todo: convert this into a for loop
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_9__.safeArrayPush)(filtersMap[param], ids.flatMap(({ docIDs  })=>docIDs));
            } else {
                const { coordinates , inside =true , highPrecision =false  } = operation[reqOperation];
                const ids = (0,_trees_bkd_js__WEBPACK_IMPORTED_MODULE_6__.searchByPolygon)(node.root, coordinates, inside, undefined, highPrecision);
                // @todo: convert this into a for loop
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_9__.safeArrayPush)(filtersMap[param], ids.flatMap(({ docIDs  })=>docIDs));
            }
            continue;
        }
        if (type === 'Radix' && (typeof operation === 'string' || Array.isArray(operation))) {
            for (const raw of [
                operation
            ].flat()){
                const term = await context.tokenizer.tokenize(raw, context.language, param);
                for (const t of term){
                    const filteredIDsResults = (0,_trees_radix_js__WEBPACK_IMPORTED_MODULE_4__.find)(node, {
                        term: t,
                        exact: true
                    });
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_9__.safeArrayPush)(filtersMap[param], Object.values(filteredIDsResults).flat());
                }
            }
            continue;
        }
        const operationKeys = Object.keys(operation);
        if (operationKeys.length > 1) {
            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_7__.createError)('INVALID_FILTER_OPERATION', operationKeys.length);
        }
        if (type === 'Flat') {
            const flatOperation = isArray ? _trees_flat_js__WEBPACK_IMPORTED_MODULE_5__.filterArr : _trees_flat_js__WEBPACK_IMPORTED_MODULE_5__.filter;
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_9__.safeArrayPush)(filtersMap[param], flatOperation(node, operation));
            continue;
        }
        if (type === 'AVL') {
            const operationOpt = operationKeys[0];
            const operationValue = operation[operationOpt];
            let filteredIDs = [];
            switch(operationOpt){
                case 'gt':
                    {
                        filteredIDs = (0,_trees_avl_js__WEBPACK_IMPORTED_MODULE_3__.greaterThan)(node, operationValue, false);
                        break;
                    }
                case 'gte':
                    {
                        filteredIDs = (0,_trees_avl_js__WEBPACK_IMPORTED_MODULE_3__.greaterThan)(node, operationValue, true);
                        break;
                    }
                case 'lt':
                    {
                        filteredIDs = (0,_trees_avl_js__WEBPACK_IMPORTED_MODULE_3__.lessThan)(node, operationValue, false);
                        break;
                    }
                case 'lte':
                    {
                        filteredIDs = (0,_trees_avl_js__WEBPACK_IMPORTED_MODULE_3__.lessThan)(node, operationValue, true);
                        break;
                    }
                case 'eq':
                    {
                        filteredIDs = (0,_trees_avl_js__WEBPACK_IMPORTED_MODULE_3__.find)(node, operationValue) ?? [];
                        break;
                    }
                case 'between':
                    {
                        const [min, max] = operationValue;
                        filteredIDs = (0,_trees_avl_js__WEBPACK_IMPORTED_MODULE_3__.rangeSearch)(node, min, max);
                        break;
                    }
            }
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_9__.safeArrayPush)(filtersMap[param], filteredIDs);
        }
    }
    // AND operation: calculate the intersection between all the IDs in filterMap
    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_9__.intersect)(Object.values(filtersMap));
}
async function getSearchableProperties(index) {
    return index.searchableProperties;
}
async function getSearchablePropertiesWithTypes(index) {
    return index.searchablePropertiesWithTypes;
}
function loadRadixNode(node) {
    const convertedNode = (0,_trees_radix_js__WEBPACK_IMPORTED_MODULE_4__.create)(node.e, node.s, node.k);
    convertedNode.d = node.d;
    convertedNode.w = node.w;
    for (const childrenKey of Object.keys(node.c)){
        convertedNode.c[childrenKey] = loadRadixNode(node.c[childrenKey]);
    }
    return convertedNode;
}
function loadFlatNode(node) {
    return {
        numberToDocumentId: new Map(node)
    };
}
function saveFlatNode(node) {
    return Array.from(node.numberToDocumentId.entries());
}
async function load(sharedInternalDocumentStore, raw) {
    const { indexes: rawIndexes , vectorIndexes: rawVectorIndexes , searchableProperties , searchablePropertiesWithTypes , frequencies , tokenOccurrences , avgFieldLength , fieldLengths  } = raw;
    const indexes = {};
    const vectorIndexes = {};
    for (const prop of Object.keys(rawIndexes)){
        const { node , type , isArray  } = rawIndexes[prop];
        switch(type){
            case 'Radix':
                indexes[prop] = {
                    type: 'Radix',
                    node: loadRadixNode(node),
                    isArray
                };
                break;
            case 'Flat':
                indexes[prop] = {
                    type: 'Flat',
                    node: loadFlatNode(node),
                    isArray
                };
                break;
            default:
                indexes[prop] = rawIndexes[prop];
        }
    }
    for (const idx of Object.keys(rawVectorIndexes)){
        const vectors = rawVectorIndexes[idx].vectors;
        for(const vec in vectors){
            vectors[vec] = [
                vectors[vec][0],
                new Float32Array(vectors[vec][1])
            ];
        }
        vectorIndexes[idx] = {
            size: rawVectorIndexes[idx].size,
            vectors
        };
    }
    return {
        sharedInternalDocumentStore,
        indexes,
        vectorIndexes,
        searchableProperties,
        searchablePropertiesWithTypes,
        frequencies,
        tokenOccurrences,
        avgFieldLength,
        fieldLengths
    };
}
async function save(index) {
    const { indexes , vectorIndexes , searchableProperties , searchablePropertiesWithTypes , frequencies , tokenOccurrences , avgFieldLength , fieldLengths  } = index;
    const vectorIndexesAsArrays = {};
    for (const idx of Object.keys(vectorIndexes)){
        const vectors = vectorIndexes[idx].vectors;
        for(const vec in vectors){
            vectors[vec] = [
                vectors[vec][0],
                Array.from(vectors[vec][1])
            ];
        }
        vectorIndexesAsArrays[idx] = {
            size: vectorIndexes[idx].size,
            vectors
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const savedIndexes = {};
    for (const name of Object.keys(indexes)){
        const { type , node , isArray  } = indexes[name];
        if (type !== 'Flat') {
            savedIndexes[name] = indexes[name];
            continue;
        }
        savedIndexes[name] = {
            type: 'Flat',
            node: saveFlatNode(node),
            isArray
        };
    }
    return {
        indexes: savedIndexes,
        vectorIndexes: vectorIndexesAsArrays,
        searchableProperties,
        searchablePropertiesWithTypes,
        frequencies,
        tokenOccurrences,
        avgFieldLength,
        fieldLengths
    };
}
async function createIndex() {
    return {
        create,
        insert,
        remove,
        insertDocumentScoreParameters,
        insertTokenScoreParameters,
        removeDocumentScoreParameters,
        removeTokenScoreParameters,
        calculateResultScores,
        search,
        searchByWhereClause,
        getSearchableProperties,
        getSearchablePropertiesWithTypes,
        load,
        save
    };
}

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/components/internal-document-id-store.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@orama/orama/dist/components/internal-document-id-store.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createInternalDocumentIDStore: () => (/* binding */ createInternalDocumentIDStore),
/* harmony export */   getDocumentIdFromInternalId: () => (/* binding */ getDocumentIdFromInternalId),
/* harmony export */   getInternalDocumentId: () => (/* binding */ getInternalDocumentId),
/* harmony export */   load: () => (/* binding */ load),
/* harmony export */   save: () => (/* binding */ save)
/* harmony export */ });
function createInternalDocumentIDStore() {
    return {
        idToInternalId: new Map(),
        internalIdToId: [],
        save,
        load
    };
}
function save(store) {
    return {
        internalIdToId: store.internalIdToId
    };
}
function load(orama, raw) {
    const { internalIdToId  } = raw;
    orama.internalDocumentIDStore.idToInternalId.clear();
    orama.internalDocumentIDStore.internalIdToId = [];
    const internalIdToIdLength = internalIdToId.length;
    for(let i = 0; i < internalIdToIdLength; i++){
        const internalIdItem = internalIdToId[i];
        orama.internalDocumentIDStore.idToInternalId.set(internalIdItem, i + 1);
        orama.internalDocumentIDStore.internalIdToId.push(internalIdItem);
    }
}
function getInternalDocumentId(store, id) {
    if (typeof id === 'string') {
        const internalId = store.idToInternalId.get(id);
        if (internalId) {
            return internalId;
        }
        const currentId = store.idToInternalId.size + 1;
        store.idToInternalId.set(id, currentId);
        store.internalIdToId.push(id);
        return currentId;
    }
    if (id > store.internalIdToId.length) {
        return getInternalDocumentId(store, id.toString());
    }
    return id;
}
function getDocumentIdFromInternalId(store, internalId) {
    if (store.internalIdToId.length < internalId) {
        throw new Error(`Invalid internalId ${internalId}`);
    }
    return store.internalIdToId[internalId - 1];
}

//# sourceMappingURL=internal-document-id-store.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/components/levenshtein.js":
/*!******************************************************************!*\
  !*** ./node_modules/@orama/orama/dist/components/levenshtein.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   boundedLevenshtein: () => (/* binding */ boundedLevenshtein),
/* harmony export */   levenshtein: () => (/* binding */ levenshtein),
/* harmony export */   syncBoundedLevenshtein: () => (/* binding */ syncBoundedLevenshtein)
/* harmony export */ });
/**
 * Inspired by:
 * https://github.com/Yomguithereal/talisman/blob/86ae55cbd040ff021d05e282e0e6c71f2dde21f8/src/metrics/levenshtein.js#L218-L340
 */ function _boundedLevenshtein(a, b, tolerance) {
    // the strings are the same
    if (a === b) {
        return 0;
    }
    // a should be the shortest string
    const swap = a;
    if (a.length > b.length) {
        a = b;
        b = swap;
    }
    let lenA = a.length;
    let lenB = b.length;
    // ignore common prefix
    let startIdx = 0;
    while(startIdx < lenA && a.charCodeAt(startIdx) === b.charCodeAt(startIdx)){
        startIdx++;
    }
    // if string A is subfix of B, we consider the distance 0
    // because we search for prefix!
    // fix https://github.com/oramasearch/orama/issues/544
    if (startIdx === lenA) {
        return 0;
    }
    // ignore common suffix
    // note: `~-` decreases by a unit in a bitwise fashion
    while(lenA > 0 && a.charCodeAt(~-lenA) === b.charCodeAt(~-lenB)){
        lenA--;
        lenB--;
    }
    // early return when the smallest string is empty
    if (!lenA) {
        return lenB > tolerance ? -1 : lenB;
    }
    lenA -= startIdx;
    lenB -= startIdx;
    // If both strings are smaller than the tolerance, we accept any distance
    // Probably the result distance is wrong, but we don't care:
    // It is always less then the tolerance!
    if (lenA <= tolerance && lenB <= tolerance) {
        return lenA > lenB ? lenA : lenB;
    }
    const delta = lenB - lenA;
    if (tolerance > lenB) {
        tolerance = lenB;
    } else if (delta > tolerance) {
        return -1;
    }
    let i = 0;
    const row = [];
    const characterCodeCache = [];
    while(i < tolerance){
        characterCodeCache[i] = b.charCodeAt(startIdx + i);
        row[i] = ++i;
    }
    while(i < lenB){
        characterCodeCache[i] = b.charCodeAt(startIdx + i);
        row[i++] = tolerance + 1;
    }
    const offset = tolerance - delta;
    const haveMax = tolerance < lenB;
    let jStart = 0;
    let jEnd = tolerance;
    let current = 0;
    let left = 0;
    let above = 0;
    let charA = 0;
    let j = 0;
    // Starting the nested loops
    for(i = 0; i < lenA; i++){
        left = i;
        current = i + 1;
        charA = a.charCodeAt(startIdx + i);
        jStart += i > offset ? 1 : 0;
        jEnd += jEnd < lenB ? 1 : 0;
        for(j = jStart; j < jEnd; j++){
            above = current;
            current = left;
            left = row[j];
            if (charA !== characterCodeCache[j]) {
                // insert current
                if (left < current) {
                    current = left;
                }
                // delete current
                if (above < current) {
                    current = above;
                }
                current++;
            }
            row[j] = current;
        }
        if (haveMax && row[i + delta] > tolerance) {
            return -1;
        }
    }
    return current <= tolerance ? current : -1;
}
/**
 * Computes the Levenshtein distance between two strings (a, b), returning early with -1 if the distance
 * is greater than the given tolerance.
 * It assumes that:
 * - tolerance >= ||a| - |b|| >= 0
 */ async function boundedLevenshtein(a, b, tolerance) {
    const distance = _boundedLevenshtein(a, b, tolerance);
    return {
        distance,
        isBounded: distance >= 0
    };
}
// This is only used internally, keep in sync with the previous one
function syncBoundedLevenshtein(a, b, tolerance) {
    const distance = _boundedLevenshtein(a, b, tolerance);
    return {
        distance,
        isBounded: distance >= 0
    };
}
function levenshtein(a, b) {
    /* c8 ignore next 3 */ if (!a.length) {
        return b.length;
    }
    /* c8 ignore next 3 */ if (!b.length) {
        return a.length;
    }
    const swap = a;
    if (a.length > b.length) {
        a = b;
        b = swap;
    }
    const row = Array.from({
        length: a.length + 1
    }, (_, i)=>i);
    let val = 0;
    for(let i = 1; i <= b.length; i++){
        let prev = i;
        for(let j = 1; j <= a.length; j++){
            if (b[i - 1] === a[j - 1]) {
                val = row[j - 1];
            } else {
                val = Math.min(row[j - 1] + 1, Math.min(prev + 1, row[j] + 1));
            }
            row[j - 1] = prev;
            prev = val;
        }
        row[a.length] = prev;
    }
    return row[a.length];
}

//# sourceMappingURL=levenshtein.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/components/plugins.js":
/*!**************************************************************!*\
  !*** ./node_modules/@orama/orama/dist/components/plugins.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVAILABLE_PLUGIN_HOOKS: () => (/* binding */ AVAILABLE_PLUGIN_HOOKS),
/* harmony export */   getAllPluginsByHook: () => (/* binding */ getAllPluginsByHook)
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ "./node_modules/@orama/orama/dist/errors.js");

const AVAILABLE_PLUGIN_HOOKS = [
    'beforeInsert',
    'afterInsert',
    'beforeRemove',
    'afterRemove',
    'beforeUpdate',
    'afterUpdate',
    'beforeSearch',
    'afterSearch',
    'beforeInsertMultiple',
    'afterInsertMultiple',
    'beforeRemoveMultiple',
    'afterRemoveMultiple',
    'beforeUpdateMultiple',
    'afterUpdateMultiple',
    'beforeLoad',
    'afterLoad',
    'afterCreate'
];
async function getAllPluginsByHook(orama, hook) {
    var _orama_plugins;
    const pluginsToRun = [];
    const pluginsLength = (_orama_plugins = orama.plugins) === null || _orama_plugins === void 0 ? void 0 : _orama_plugins.length;
    if (!pluginsLength) {
        return pluginsToRun;
    }
    for(let i = 0; i < pluginsLength; i++){
        try {
            const plugin = await orama.plugins[i];
            if (typeof plugin[hook] === 'function') {
                pluginsToRun.push(plugin[hook]);
            }
        } catch (error) {
            console.error('Caught error in getAllPluginsByHook:', error);
            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.createError)('PLUGIN_CRASHED');
        }
    }
    return pluginsToRun;
}

//# sourceMappingURL=plugins.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/components/sorter.js":
/*!*************************************************************!*\
  !*** ./node_modules/@orama/orama/dist/components/sorter.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSorter: () => (/* binding */ createSorter),
/* harmony export */   load: () => (/* binding */ load),
/* harmony export */   save: () => (/* binding */ save)
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors.js */ "./node_modules/@orama/orama/dist/errors.js");
/* harmony import */ var _defaults_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaults.js */ "./node_modules/@orama/orama/dist/components/defaults.js");
/* harmony import */ var _internal_document_id_store_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal-document-id-store.js */ "./node_modules/@orama/orama/dist/components/internal-document-id-store.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/@orama/orama/dist/utils.js");
/* harmony import */ var _tokenizer_languages_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tokenizer/languages.js */ "./node_modules/@orama/orama/dist/components/tokenizer/languages.js");





function innerCreate(orama, sharedInternalDocumentStore, schema, sortableDeniedProperties, prefix) {
    const sorter = {
        language: orama.tokenizer.language,
        sharedInternalDocumentStore,
        enabled: true,
        isSorted: true,
        sortableProperties: [],
        sortablePropertiesWithTypes: {},
        sorts: {}
    };
    for (const [prop, type] of Object.entries(schema)){
        const path = `${prefix}${prefix ? '.' : ''}${prop}`;
        if (sortableDeniedProperties.includes(path)) {
            continue;
        }
        if (typeof type === 'object' && !Array.isArray(type)) {
            // Nested
            const ret = innerCreate(orama, sharedInternalDocumentStore, type, sortableDeniedProperties, path);
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.safeArrayPush)(sorter.sortableProperties, ret.sortableProperties);
            sorter.sorts = {
                ...sorter.sorts,
                ...ret.sorts
            };
            sorter.sortablePropertiesWithTypes = {
                ...sorter.sortablePropertiesWithTypes,
                ...ret.sortablePropertiesWithTypes
            };
            continue;
        }
        if (!(0,_defaults_js__WEBPACK_IMPORTED_MODULE_1__.isVectorType)(type)) {
            switch(type){
                case 'boolean':
                case 'number':
                case 'string':
                    sorter.sortableProperties.push(path);
                    sorter.sortablePropertiesWithTypes[path] = type;
                    sorter.sorts[path] = {
                        docs: new Map(),
                        orderedDocsToRemove: new Map(),
                        orderedDocs: [],
                        type: type
                    };
                    break;
                case 'geopoint':
                case 'enum':
                    continue;
                case 'enum[]':
                case 'boolean[]':
                case 'number[]':
                case 'string[]':
                    continue;
                default:
                    throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.createError)('INVALID_SORT_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path);
            }
        }
    }
    return sorter;
}
async function create(orama, sharedInternalDocumentStore, schema, config) {
    const isSortEnabled = (config === null || config === void 0 ? void 0 : config.enabled) !== false;
    if (!isSortEnabled) {
        return {
            disabled: true
        };
    }
    return innerCreate(orama, sharedInternalDocumentStore, schema, (config || {}).unsortableProperties || [], '');
}
async function insert(sorter, prop, id, value) {
    if (!sorter.enabled) {
        return;
    }
    sorter.isSorted = false;
    const internalId = (0,_internal_document_id_store_js__WEBPACK_IMPORTED_MODULE_3__.getInternalDocumentId)(sorter.sharedInternalDocumentStore, id);
    const s = sorter.sorts[prop];
    // This happen during a document updating
    // Because we re-use the same internalId
    // We need to clean-up the data structure before re-inserting
    // to avoid duplicates in the orderedDocs array
    // See: https://github.com/oramasearch/orama/issues/629
    if (s.orderedDocsToRemove.has(internalId)) {
        ensureOrderedDocsAreDeletedByProperty(sorter, prop);
    }
    s.docs.set(internalId, s.orderedDocs.length);
    s.orderedDocs.push([
        internalId,
        value
    ]);
}
function ensureIsSorted(sorter) {
    if (sorter.isSorted || !sorter.enabled) {
        return;
    }
    const properties = Object.keys(sorter.sorts);
    for (const prop of properties){
        ensurePropertyIsSorted(sorter, prop);
    }
    sorter.isSorted = true;
}
function stringSort(language, value, d) {
    return value[1].localeCompare(d[1], (0,_tokenizer_languages_js__WEBPACK_IMPORTED_MODULE_4__.getLocale)(language));
}
function numberSort(value, d) {
    return value[1] - d[1];
}
function booleanSort(value, d) {
    return d[1] ? -1 : 1;
}
function ensurePropertyIsSorted(sorter, prop) {
    const s = sorter.sorts[prop];
    let predicate;
    switch(s.type){
        case 'string':
            predicate = stringSort.bind(null, sorter.language);
            break;
        case 'number':
            predicate = numberSort.bind(null);
            break;
        case 'boolean':
            predicate = booleanSort.bind(null);
            break;
    }
    s.orderedDocs.sort(predicate);
    // Increment position for the greather documents
    const orderedDocsLength = s.orderedDocs.length;
    for(let i = 0; i < orderedDocsLength; i++){
        const docId = s.orderedDocs[i][0];
        s.docs.set(docId, i);
    }
}
function ensureOrderedDocsAreDeleted(sorter) {
    const properties = Object.keys(sorter.sorts);
    for (const prop of properties){
        ensureOrderedDocsAreDeletedByProperty(sorter, prop);
    }
}
function ensureOrderedDocsAreDeletedByProperty(sorter, prop) {
    const s = sorter.sorts[prop];
    if (!s.orderedDocsToRemove.size) return;
    s.orderedDocs = s.orderedDocs.filter((doc)=>!s.orderedDocsToRemove.has(doc[0]));
    s.orderedDocsToRemove.clear();
}
async function remove(sorter, prop, id) {
    if (!sorter.enabled) {
        return;
    }
    const s = sorter.sorts[prop];
    const internalId = (0,_internal_document_id_store_js__WEBPACK_IMPORTED_MODULE_3__.getInternalDocumentId)(sorter.sharedInternalDocumentStore, id);
    const index = s.docs.get(internalId);
    if (!index) return;
    s.docs.delete(internalId);
    s.orderedDocsToRemove.set(internalId, true);
}
async function sortBy(sorter, docIds, by) {
    if (!sorter.enabled) {
        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.createError)('SORT_DISABLED');
    }
    const property = by.property;
    const isDesc = by.order === 'DESC';
    const s = sorter.sorts[property];
    if (!s) {
        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.createError)('UNABLE_TO_SORT_ON_UNKNOWN_FIELD', property, sorter.sortableProperties.join(', '));
    }
    ensureOrderedDocsAreDeletedByProperty(sorter, property);
    ensureIsSorted(sorter);
    docIds.sort((a, b)=>{
        // This sort algorithm works leveraging on
        // that s.docs is a map of docId -> position
        // If a document is not indexed, it will be not present in the map
        const indexOfA = s.docs.get((0,_internal_document_id_store_js__WEBPACK_IMPORTED_MODULE_3__.getInternalDocumentId)(sorter.sharedInternalDocumentStore, a[0]));
        const indexOfB = s.docs.get((0,_internal_document_id_store_js__WEBPACK_IMPORTED_MODULE_3__.getInternalDocumentId)(sorter.sharedInternalDocumentStore, b[0]));
        const isAIndexed = typeof indexOfA !== 'undefined';
        const isBIndexed = typeof indexOfB !== 'undefined';
        if (!isAIndexed && !isBIndexed) {
            return 0;
        }
        // unindexed documents are always at the end
        if (!isAIndexed) {
            return 1;
        }
        if (!isBIndexed) {
            return -1;
        }
        return isDesc ? indexOfB - indexOfA : indexOfA - indexOfB;
    });
    return docIds;
}
async function getSortableProperties(sorter) {
    if (!sorter.enabled) {
        return [];
    }
    return sorter.sortableProperties;
}
async function getSortablePropertiesWithTypes(sorter) {
    if (!sorter.enabled) {
        return {};
    }
    return sorter.sortablePropertiesWithTypes;
}
async function load(sharedInternalDocumentStore, raw) {
    const rawDocument = raw;
    if (!rawDocument.enabled) {
        return {
            enabled: false
        };
    }
    const sorts = Object.keys(rawDocument.sorts).reduce((acc, prop)=>{
        const { docs , orderedDocs , type  } = rawDocument.sorts[prop];
        acc[prop] = {
            docs: new Map(Object.entries(docs).map(([k, v])=>[
                    +k,
                    v
                ])),
            orderedDocsToRemove: new Map(),
            orderedDocs,
            type
        };
        return acc;
    }, {});
    return {
        sharedInternalDocumentStore,
        language: rawDocument.language,
        sortableProperties: rawDocument.sortableProperties,
        sortablePropertiesWithTypes: rawDocument.sortablePropertiesWithTypes,
        sorts,
        enabled: true,
        isSorted: rawDocument.isSorted
    };
}
async function save(sorter) {
    if (!sorter.enabled) {
        return {
            enabled: false
        };
    }
    ensureOrderedDocsAreDeleted(sorter);
    ensureIsSorted(sorter);
    const sorts = Object.keys(sorter.sorts).reduce((acc, prop)=>{
        const { docs , orderedDocs , type  } = sorter.sorts[prop];
        acc[prop] = {
            docs: Object.fromEntries(docs.entries()),
            orderedDocs,
            type
        };
        return acc;
    }, {});
    return {
        language: sorter.language,
        sortableProperties: sorter.sortableProperties,
        sortablePropertiesWithTypes: sorter.sortablePropertiesWithTypes,
        sorts,
        enabled: sorter.enabled,
        isSorted: sorter.isSorted
    };
}
async function createSorter() {
    return {
        create,
        insert,
        remove,
        save,
        load,
        sortBy,
        getSortableProperties,
        getSortablePropertiesWithTypes
    };
}

//# sourceMappingURL=sorter.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/components/sync-blocking-checker.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@orama/orama/dist/components/sync-blocking-checker.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   trackInsertion: () => (/* binding */ trackInsertion),
/* harmony export */   trackRemoval: () => (/* binding */ trackRemoval)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types.js */ "./node_modules/@orama/orama/dist/types.js");
var _globalThis_process;

// Web platforms don't have process. React-Native doesn't have process.emitWarning.
const warn = ((_globalThis_process = globalThis.process) === null || _globalThis_process === void 0 ? void 0 : _globalThis_process.emitWarning) ?? function emitWarning(message, options) {
    console.warn(`[WARNING] [${options.code}] ${message}`);
};
function trackInsertion(orama) {
    if (typeof orama[_types_js__WEBPACK_IMPORTED_MODULE_0__.kInsertions] !== 'number') {
        queueMicrotask(()=>{
            orama[_types_js__WEBPACK_IMPORTED_MODULE_0__.kInsertions] = undefined;
        });
        orama[_types_js__WEBPACK_IMPORTED_MODULE_0__.kInsertions] = 0;
    }
    if (orama[_types_js__WEBPACK_IMPORTED_MODULE_0__.kInsertions] > 1000) {
        warn("Orama's insert operation is synchronous. Please avoid inserting a large number of document in a single operation in order not to block the main thread or, in alternative, please use insertMultiple.", {
            code: 'ORAMA0001'
        });
        orama[_types_js__WEBPACK_IMPORTED_MODULE_0__.kInsertions] = -1;
    } else if (orama[_types_js__WEBPACK_IMPORTED_MODULE_0__.kInsertions] >= 0) {
        orama[_types_js__WEBPACK_IMPORTED_MODULE_0__.kInsertions]++;
    }
}
function trackRemoval(orama) {
    if (typeof orama[_types_js__WEBPACK_IMPORTED_MODULE_0__.kRemovals] !== 'number') {
        queueMicrotask(()=>{
            orama[_types_js__WEBPACK_IMPORTED_MODULE_0__.kRemovals] = undefined;
        });
        orama[_types_js__WEBPACK_IMPORTED_MODULE_0__.kRemovals] = 0;
    }
    if (orama[_types_js__WEBPACK_IMPORTED_MODULE_0__.kRemovals] > 1000) {
        warn("Orama's remove operation is synchronous. Please avoid removing a large number of document in a single operation in order not to block the main thread, in alternative, please use updateMultiple.", {
            code: 'ORAMA0002'
        });
        orama[_types_js__WEBPACK_IMPORTED_MODULE_0__.kRemovals] = -1;
    } else if (orama[_types_js__WEBPACK_IMPORTED_MODULE_0__.kRemovals] >= 0) {
        orama[_types_js__WEBPACK_IMPORTED_MODULE_0__.kRemovals]++;
    }
}

//# sourceMappingURL=sync-blocking-checker.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/components/tokenizer/diacritics.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@orama/orama/dist/components/tokenizer/diacritics.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   replaceDiacritics: () => (/* binding */ replaceDiacritics)
/* harmony export */ });
const DIACRITICS_CHARCODE_START = 192;
const DIACRITICS_CHARCODE_END = 383;
const CHARCODE_REPLACE_MAPPING = [
    65,
    65,
    65,
    65,
    65,
    65,
    65,
    67,
    69,
    69,
    69,
    69,
    73,
    73,
    73,
    73,
    69,
    78,
    79,
    79,
    79,
    79,
    79,
    null,
    79,
    85,
    85,
    85,
    85,
    89,
    80,
    115,
    97,
    97,
    97,
    97,
    97,
    97,
    97,
    99,
    101,
    101,
    101,
    101,
    105,
    105,
    105,
    105,
    101,
    110,
    111,
    111,
    111,
    111,
    111,
    null,
    111,
    117,
    117,
    117,
    117,
    121,
    112,
    121,
    65,
    97,
    65,
    97,
    65,
    97,
    67,
    99,
    67,
    99,
    67,
    99,
    67,
    99,
    68,
    100,
    68,
    100,
    69,
    101,
    69,
    101,
    69,
    101,
    69,
    101,
    69,
    101,
    71,
    103,
    71,
    103,
    71,
    103,
    71,
    103,
    72,
    104,
    72,
    104,
    73,
    105,
    73,
    105,
    73,
    105,
    73,
    105,
    73,
    105,
    73,
    105,
    74,
    106,
    75,
    107,
    107,
    76,
    108,
    76,
    108,
    76,
    108,
    76,
    108,
    76,
    108,
    78,
    110,
    78,
    110,
    78,
    110,
    110,
    78,
    110,
    79,
    111,
    79,
    111,
    79,
    111,
    79,
    111,
    82,
    114,
    82,
    114,
    82,
    114,
    83,
    115,
    83,
    115,
    83,
    115,
    83,
    115,
    84,
    116,
    84,
    116,
    84,
    116,
    85,
    117,
    85,
    117,
    85,
    117,
    85,
    117,
    85,
    117,
    85,
    117,
    87,
    119,
    89,
    121,
    89,
    90,
    122,
    90,
    122,
    90,
    122,
    115
];
function replaceChar(charCode) {
    if (charCode < DIACRITICS_CHARCODE_START || charCode > DIACRITICS_CHARCODE_END) return charCode;
    /* c8 ignore next  */ return CHARCODE_REPLACE_MAPPING[charCode - DIACRITICS_CHARCODE_START] || charCode;
}
function replaceDiacritics(str) {
    const stringCharCode = [];
    for(let idx = 0; idx < str.length; idx++){
        stringCharCode[idx] = replaceChar(str.charCodeAt(idx));
    }
    return String.fromCharCode(...stringCharCode);
}

//# sourceMappingURL=diacritics.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/components/tokenizer/english-stemmer.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@orama/orama/dist/components/tokenizer/english-stemmer.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   stemmer: () => (/* binding */ stemmer)
/* harmony export */ });
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
const step2List = {
    ational: 'ate',
    tional: 'tion',
    enci: 'ence',
    anci: 'ance',
    izer: 'ize',
    bli: 'ble',
    alli: 'al',
    entli: 'ent',
    eli: 'e',
    ousli: 'ous',
    ization: 'ize',
    ation: 'ate',
    ator: 'ate',
    alism: 'al',
    iveness: 'ive',
    fulness: 'ful',
    ousness: 'ous',
    aliti: 'al',
    iviti: 'ive',
    biliti: 'ble',
    logi: 'log'
};
const step3List = {
    icate: 'ic',
    ative: '',
    alize: 'al',
    iciti: 'ic',
    ical: 'ic',
    ful: '',
    ness: ''
};
// Consonant
const c = '[^aeiou]';
// Vowel
const v = '[aeiouy]';
// Consonant sequence
const C = c + '[^aeiouy]*';
// Vowel sequence
const V = v + '[aeiou]*';
// [C]VC... is m>0
const mgr0 = '^(' + C + ')?' + V + C;
// [C]VC[V] is m=1
const meq1 = '^(' + C + ')?' + V + C + '(' + V + ')?$';
// [C]VCVC... is m>1
const mgr1 = '^(' + C + ')?' + V + C + V + C;
// vowel in stem
const s_v = '^(' + C + ')?' + v;
function stemmer(w) {
    let stem;
    let suffix;
    let re;
    let re2;
    let re3;
    let re4;
    if (w.length < 3) {
        return w;
    }
    const firstch = w.substring(0, 1);
    if (firstch == 'y') {
        w = firstch.toUpperCase() + w.substring(1);
    }
    re = /^(.+?)(ss|i)es$/;
    re2 = /^(.+?)([^s])s$/;
    if (re.test(w)) {
        w = w.replace(re, '$1$2');
    } else if (re2.test(w)) {
        w = w.replace(re2, '$1$2');
    }
    re = /^(.+?)eed$/;
    re2 = /^(.+?)(ed|ing)$/;
    if (re.test(w)) {
        const fp = re.exec(w);
        re = new RegExp(mgr0);
        if (re.test(fp[1])) {
            re = /.$/;
            w = w.replace(re, '');
        }
    } else if (re2.test(w)) {
        const fp = re2.exec(w);
        stem = fp[1];
        re2 = new RegExp(s_v);
        if (re2.test(stem)) {
            w = stem;
            re2 = /(at|bl|iz)$/;
            re3 = new RegExp('([^aeiouylsz])\\1$');
            re4 = new RegExp('^' + C + v + '[^aeiouwxy]$');
            if (re2.test(w)) {
                w = w + 'e';
            } else if (re3.test(w)) {
                re = /.$/;
                w = w.replace(re, '');
            } else if (re4.test(w)) {
                w = w + 'e';
            }
        }
    }
    re = /^(.+?)y$/;
    if (re.test(w)) {
        const fp = re.exec(w);
        stem = fp === null || fp === void 0 ? void 0 : fp[1];
        re = new RegExp(s_v);
        if (stem && re.test(stem)) {
            w = stem + 'i';
        }
    }
    re = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
    if (re.test(w)) {
        const fp = re.exec(w);
        stem = fp === null || fp === void 0 ? void 0 : fp[1];
        suffix = fp === null || fp === void 0 ? void 0 : fp[2];
        re = new RegExp(mgr0);
        if (stem && re.test(stem)) {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            w = stem + step2List[suffix];
        }
    }
    re = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
    if (re.test(w)) {
        const fp = re.exec(w);
        stem = fp === null || fp === void 0 ? void 0 : fp[1];
        suffix = fp === null || fp === void 0 ? void 0 : fp[2];
        re = new RegExp(mgr0);
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        if (stem && re.test(stem)) {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            w = stem + step3List[suffix];
        }
    }
    re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
    re2 = /^(.+?)(s|t)(ion)$/;
    if (re.test(w)) {
        const fp = re.exec(w);
        stem = fp === null || fp === void 0 ? void 0 : fp[1];
        re = new RegExp(mgr1);
        if (stem && re.test(stem)) {
            w = stem;
        }
    } else if (re2.test(w)) {
        const fp = re2.exec(w);
        stem = (fp === null || fp === void 0 ? void 0 : fp[1]) ?? '' + (fp === null || fp === void 0 ? void 0 : fp[2]) ?? '';
        re2 = new RegExp(mgr1);
        if (re2.test(stem)) {
            w = stem;
        }
    }
    re = /^(.+?)e$/;
    if (re.test(w)) {
        const fp = re.exec(w);
        stem = fp === null || fp === void 0 ? void 0 : fp[1];
        re = new RegExp(mgr1);
        re2 = new RegExp(meq1);
        re3 = new RegExp('^' + C + v + '[^aeiouwxy]$');
        if (stem && (re.test(stem) || re2.test(stem) && !re3.test(stem))) {
            w = stem;
        }
    }
    re = /ll$/;
    re2 = new RegExp(mgr1);
    if (re.test(w) && re2.test(w)) {
        re = /.$/;
        w = w.replace(re, '');
    }
    if (firstch == 'y') {
        w = firstch.toLowerCase() + w.substring(1);
    }
    return w;
}

//# sourceMappingURL=english-stemmer.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/components/tokenizer/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@orama/orama/dist/components/tokenizer/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createTokenizer: () => (/* binding */ createTokenizer),
/* harmony export */   normalizeToken: () => (/* binding */ normalizeToken)
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../errors.js */ "./node_modules/@orama/orama/dist/errors.js");
/* harmony import */ var _diacritics_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./diacritics.js */ "./node_modules/@orama/orama/dist/components/tokenizer/diacritics.js");
/* harmony import */ var _languages_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./languages.js */ "./node_modules/@orama/orama/dist/components/tokenizer/languages.js");
/* harmony import */ var _english_stemmer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./english-stemmer.js */ "./node_modules/@orama/orama/dist/components/tokenizer/english-stemmer.js");




function normalizeToken(prop, token) {
    var _this_stopWords;
    const key = `${this.language}:${prop}:${token}`;
    if (this.normalizationCache.has(key)) {
        return this.normalizationCache.get(key);
    }
    // Remove stopwords if enabled
    if ((_this_stopWords = this.stopWords) === null || _this_stopWords === void 0 ? void 0 : _this_stopWords.includes(token)) {
        this.normalizationCache.set(key, '');
        return '';
    }
    // Apply stemming if enabled
    if (this.stemmer && !this.stemmerSkipProperties.has(prop)) {
        token = this.stemmer(token);
    }
    token = (0,_diacritics_js__WEBPACK_IMPORTED_MODULE_0__.replaceDiacritics)(token);
    this.normalizationCache.set(key, token);
    return token;
}
/* c8 ignore next 10 */ function trim(text) {
    while(text[text.length - 1] === ''){
        text.pop();
    }
    while(text[0] === ''){
        text.shift();
    }
    return text;
}
function tokenize(input, language, prop) {
    if (language && language !== this.language) {
        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_1__.createError)('LANGUAGE_NOT_SUPPORTED', language);
    }
    /* c8 ignore next 3 */ if (typeof input !== 'string') {
        return [
            input
        ];
    }
    let tokens;
    if (prop && this.tokenizeSkipProperties.has(prop)) {
        tokens = [
            this.normalizeToken.bind(this, prop ?? '')(input)
        ];
    } else {
        const splitRule = _languages_js__WEBPACK_IMPORTED_MODULE_2__.SPLITTERS[this.language];
        tokens = input.toLowerCase().split(splitRule).map(this.normalizeToken.bind(this, prop ?? '')).filter(Boolean);
    }
    const trimTokens = trim(tokens);
    if (!this.allowDuplicates) {
        return Array.from(new Set(trimTokens));
    }
    return trimTokens;
}
async function createTokenizer(config = {}) {
    if (!config.language) {
        config.language = 'english';
    } else if (!_languages_js__WEBPACK_IMPORTED_MODULE_2__.SUPPORTED_LANGUAGES.includes(config.language)) {
        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_1__.createError)('LANGUAGE_NOT_SUPPORTED', config.language);
    }
    // Handle stemming - It is disabled by default
    let stemmer;
    if (config.stemming || config.stemmer && !('stemming' in config)) {
        if (config.stemmer) {
            if (typeof config.stemmer !== 'function') {
                throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_1__.createError)('INVALID_STEMMER_FUNCTION_TYPE');
            }
            stemmer = config.stemmer;
        } else {
            if (config.language === 'english') {
                stemmer = _english_stemmer_js__WEBPACK_IMPORTED_MODULE_3__.stemmer;
            } else {
                throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_1__.createError)('MISSING_STEMMER', config.language);
            }
        }
    }
    // Handle stopwords
    let stopWords;
    if (config.stopWords !== false) {
        stopWords = [];
        if (Array.isArray(config.stopWords)) {
            stopWords = config.stopWords;
        } else if (typeof config.stopWords === 'function') {
            stopWords = await config.stopWords(stopWords);
        } else if (config.stopWords) {
            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_1__.createError)('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY');
        }
        // Make sure stopWords is just an array of strings
        if (!Array.isArray(stopWords)) {
            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_1__.createError)('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY');
        }
        for (const s of stopWords){
            if (typeof s !== 'string') {
                throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_1__.createError)('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY');
            }
        }
    }
    // Create the tokenizer
    const tokenizer = {
        tokenize,
        language: config.language,
        stemmer,
        stemmerSkipProperties: new Set(config.stemmerSkipProperties ? [
            config.stemmerSkipProperties
        ].flat() : []),
        tokenizeSkipProperties: new Set(config.tokenizeSkipProperties ? [
            config.tokenizeSkipProperties
        ].flat() : []),
        stopWords,
        allowDuplicates: Boolean(config.allowDuplicates),
        normalizeToken,
        normalizationCache: new Map()
    };
    tokenizer.tokenize = tokenize.bind(tokenizer);
    tokenizer.normalizeToken = normalizeToken;
    return tokenizer;
}

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/components/tokenizer/languages.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@orama/orama/dist/components/tokenizer/languages.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SPLITTERS: () => (/* binding */ SPLITTERS),
/* harmony export */   STEMMERS: () => (/* binding */ STEMMERS),
/* harmony export */   SUPPORTED_LANGUAGES: () => (/* binding */ SUPPORTED_LANGUAGES),
/* harmony export */   getLocale: () => (/* binding */ getLocale)
/* harmony export */ });
const STEMMERS = {
    arabic: 'ar',
    armenian: 'am',
    bulgarian: 'bg',
    danish: 'dk',
    dutch: 'nl',
    english: 'en',
    finnish: 'fi',
    french: 'fr',
    german: 'de',
    greek: 'gr',
    hungarian: 'hu',
    indian: 'in',
    indonesian: 'id',
    irish: 'ie',
    italian: 'it',
    lithuanian: 'lt',
    nepali: 'np',
    norwegian: 'no',
    portuguese: 'pt',
    romanian: 'ro',
    russian: 'ru',
    serbian: 'rs',
    slovenian: 'ru',
    spanish: 'es',
    swedish: 'se',
    tamil: 'ta',
    turkish: 'tr',
    ukrainian: 'uk',
    sanskrit: 'sk'
};
const SPLITTERS = {
    dutch: /[^A-Za-z0-9_'-]+/gim,
    english: /[^A-Za-z0-9_'-]+/gim,
    french: /[^a-z0-9-]+/gim,
    italian: /[^A-Za-z0-9_'-]+/gim,
    norwegian: /[^a-z0-9_]+/gim,
    portuguese: /[^a-z0-9--]/gim,
    russian: /[^a-z0-9--]+/gim,
    spanish: /[^a-z0-9A-Z--]+/gim,
    swedish: /[^a-z0-9_-]+/gim,
    german: /[^a-z0-9A-Z]+/gim,
    finnish: /[^a-z0-9]+/gim,
    danish: /[^a-z0-9]+/gim,
    hungarian: /[^a-z0-9]+/gim,
    romanian: /[^a-z0-9]+/gim,
    serbian: /[^a-z0-9]+/gim,
    turkish: /[^a-z0-9]+/gim,
    lithuanian: /[^a-z0-9]+/gim,
    arabic: /[^a-z0-9-]+/gim,
    nepali: /[^a-z0-9-]+/gim,
    irish: /[^a-z0-9]+/gim,
    indian: /[^a-z0-9-]+/gim,
    armenian: /[^a-z0-9-]+/gim,
    greek: /[^a-z0-9--]+/gim,
    indonesian: /[^a-z0-9]+/gim,
    ukrainian: /[^a-z0-9--]+/gim,
    slovenian: /[^a-z0-9]+/gim,
    bulgarian: /[^a-z0-9--]+/gim,
    tamil: /[^a-z0-9-]+/gim,
    sanskrit: /[^a-z0-9A-Z]+/gim
};
const SUPPORTED_LANGUAGES = Object.keys(STEMMERS);
function getLocale(language) {
    return language !== undefined && SUPPORTED_LANGUAGES.includes(language) ? STEMMERS[language] : undefined;
}

//# sourceMappingURL=languages.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/@orama/orama/dist/constants.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MODE_FULLTEXT_SEARCH: () => (/* binding */ MODE_FULLTEXT_SEARCH),
/* harmony export */   MODE_HYBRID_SEARCH: () => (/* binding */ MODE_HYBRID_SEARCH),
/* harmony export */   MODE_VECTOR_SEARCH: () => (/* binding */ MODE_VECTOR_SEARCH)
/* harmony export */ });
const MODE_FULLTEXT_SEARCH = 'fulltext';
const MODE_HYBRID_SEARCH = 'hybrid';
const MODE_VECTOR_SEARCH = 'vector';

//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/errors.js":
/*!**************************************************!*\
  !*** ./node_modules/@orama/orama/dist/errors.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createError: () => (/* binding */ createError)
/* harmony export */ });
/* harmony import */ var _components_tokenizer_languages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/tokenizer/languages.js */ "./node_modules/@orama/orama/dist/components/tokenizer/languages.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@orama/orama/dist/utils.js");


const allLanguages = _components_tokenizer_languages_js__WEBPACK_IMPORTED_MODULE_0__.SUPPORTED_LANGUAGES.join('\n - ');
const errors = {
    NO_LANGUAGE_WITH_CUSTOM_TOKENIZER: 'Do not pass the language option to create when using a custom tokenizer.',
    LANGUAGE_NOT_SUPPORTED: `Language "%s" is not supported.\nSupported languages are:\n - ${allLanguages}`,
    INVALID_STEMMER_FUNCTION_TYPE: `config.stemmer property must be a function.`,
    MISSING_STEMMER: `As of version 1.0.0 @orama/orama does not ship non English stemmers by default. To solve this, please explicitly import and specify the "%s" stemmer from the package @orama/stemmers. See https://docs.oramasearch.com/open-source/text-analysis/stemming for more information.`,
    CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY: 'Custom stop words array must only contain strings.',
    UNSUPPORTED_COMPONENT: `Unsupported component "%s".`,
    COMPONENT_MUST_BE_FUNCTION: `The component "%s" must be a function.`,
    COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS: `The component "%s" must be a function or an array of functions.`,
    INVALID_SCHEMA_TYPE: `Unsupported schema type "%s" at "%s". Expected "string", "boolean" or "number" or array of them.`,
    DOCUMENT_ID_MUST_BE_STRING: `Document id must be of type "string". Got "%s" instead.`,
    DOCUMENT_ALREADY_EXISTS: `A document with id "%s" already exists.`,
    DOCUMENT_DOES_NOT_EXIST: `A document with id "%s" does not exists.`,
    MISSING_DOCUMENT_PROPERTY: `Missing searchable property "%s".`,
    INVALID_DOCUMENT_PROPERTY: `Invalid document property "%s": expected "%s", got "%s"`,
    UNKNOWN_INDEX: `Invalid property name "%s". Expected a wildcard string ("*") or array containing one of the following properties: %s`,
    INVALID_BOOST_VALUE: `Boost value must be a number greater than, or less than 0.`,
    INVALID_FILTER_OPERATION: `You can only use one operation per filter, you requested %d.`,
    SCHEMA_VALIDATION_FAILURE: `Cannot insert document due schema validation failure on "%s" property.`,
    INVALID_SORT_SCHEMA_TYPE: `Unsupported sort schema type "%s" at "%s". Expected "string" or "number".`,
    CANNOT_SORT_BY_ARRAY: `Cannot configure sort for "%s" because it is an array (%s).`,
    UNABLE_TO_SORT_ON_UNKNOWN_FIELD: `Unable to sort on unknown field "%s". Allowed fields: %s`,
    SORT_DISABLED: `Sort is disabled. Please read the documentation at https://docs.oramasearch for more information.`,
    UNKNOWN_GROUP_BY_PROPERTY: `Unknown groupBy property "%s".`,
    INVALID_GROUP_BY_PROPERTY: `Invalid groupBy property "%s". Allowed types: "%s", but given "%s".`,
    UNKNOWN_FILTER_PROPERTY: `Unknown filter property "%s".`,
    INVALID_VECTOR_SIZE: `Vector size must be a number greater than 0. Got "%s" instead.`,
    INVALID_VECTOR_VALUE: `Vector value must be a number greater than 0. Got "%s" instead.`,
    INVALID_INPUT_VECTOR: `Property "%s" was declared as a %s-dimensional vector, but got a %s-dimensional vector instead.\nInput vectors must be of the size declared in the schema, as calculating similarity between vectors of different sizes can lead to unexpected results.`,
    WRONG_SEARCH_PROPERTY_TYPE: `Property "%s" is not searchable. Only "string" properties are searchable.`,
    FACET_NOT_SUPPORTED: `Facet doens't support the type "%s".`,
    INVALID_DISTANCE_SUFFIX: `Invalid distance suffix "%s". Valid suffixes are: cm, m, km, mi, yd, ft.`,
    INVALID_SEARCH_MODE: `Invalid search mode "%s". Valid modes are: "fulltext", "vector", "hybrid".`,
    MISSING_VECTOR_AND_SECURE_PROXY: `No vector was provided and no secure proxy was configured. Please provide a vector or configure an Orama Secure Proxy to perform hybrid search.`,
    MISSING_TERM: `"term" is a required parameter when performing hybrid search. Please provide a search term.`,
    INVALID_VECTOR_INPUT: `Invalid "vector" property. Expected an object with "value" and "property" properties, but got "%s" instead.`,
    PLUGIN_CRASHED: `A plugin crashed during initialization. Please check the error message for more information:`
};
function createError(code, ...args) {
    const error = new Error((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.sprintf)(errors[code] ?? `Unsupported Orama Error code: ${code}`, ...args));
    error.code = code;
    if ('captureStackTrace' in Error.prototype) {
        Error.captureStackTrace(error);
    }
    return error;
}

//# sourceMappingURL=errors.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/methods/create.js":
/*!**********************************************************!*\
  !*** ./node_modules/@orama/orama/dist/methods/create.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   create: () => (/* binding */ create)
/* harmony export */ });
/* harmony import */ var _components_defaults_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/defaults.js */ "./node_modules/@orama/orama/dist/components/defaults.js");
/* harmony import */ var _components_defaults_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ "./node_modules/@orama/orama/dist/utils.js");
/* harmony import */ var _components_documents_store_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../components/documents-store.js */ "./node_modules/@orama/orama/dist/components/documents-store.js");
/* harmony import */ var _components_plugins_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../components/plugins.js */ "./node_modules/@orama/orama/dist/components/plugins.js");
/* harmony import */ var _components_hooks_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/hooks.js */ "./node_modules/@orama/orama/dist/components/hooks.js");
/* harmony import */ var _components_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../components/index.js */ "./node_modules/@orama/orama/dist/components/index.js");
/* harmony import */ var _components_internal_document_id_store_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/internal-document-id-store.js */ "./node_modules/@orama/orama/dist/components/internal-document-id-store.js");
/* harmony import */ var _components_sorter_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/sorter.js */ "./node_modules/@orama/orama/dist/components/sorter.js");
/* harmony import */ var _components_tokenizer_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/tokenizer/index.js */ "./node_modules/@orama/orama/dist/components/tokenizer/index.js");
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors.js */ "./node_modules/@orama/orama/dist/errors.js");










function validateComponents(components) {
    const defaultComponents = {
        formatElapsedTime: _components_defaults_js__WEBPACK_IMPORTED_MODULE_0__.formatElapsedTime,
        getDocumentIndexId: _components_defaults_js__WEBPACK_IMPORTED_MODULE_0__.getDocumentIndexId,
        getDocumentProperties: _components_defaults_js__WEBPACK_IMPORTED_MODULE_1__.getDocumentProperties,
        validateSchema: _components_defaults_js__WEBPACK_IMPORTED_MODULE_0__.validateSchema
    };
    for (const rawKey of _components_hooks_js__WEBPACK_IMPORTED_MODULE_2__.FUNCTION_COMPONENTS){
        const key = rawKey;
        if (components[key]) {
            if (typeof components[key] !== 'function') {
                throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.createError)('COMPONENT_MUST_BE_FUNCTION', key);
            }
        } else {
            // @ts-expect-error TSC is unable to resolve this
            components[key] = defaultComponents[key];
        }
    }
    for (const rawKey of Object.keys(components)){
        if (!_components_hooks_js__WEBPACK_IMPORTED_MODULE_2__.OBJECT_COMPONENTS.includes(rawKey) && !_components_hooks_js__WEBPACK_IMPORTED_MODULE_2__.FUNCTION_COMPONENTS.includes(rawKey)) {
            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.createError)('UNSUPPORTED_COMPONENT', rawKey);
        }
    }
}
async function create({ schema , sort , language , components , id , plugins  }) {
    if (!components) {
        components = {};
    }
    if (!id) {
        id = await (0,_components_defaults_js__WEBPACK_IMPORTED_MODULE_1__.uniqueId)();
    }
    let tokenizer = components.tokenizer;
    let index = components.index;
    let documentsStore = components.documentsStore;
    let sorter = components.sorter;
    if (!tokenizer) {
        // Use the default tokenizer
        tokenizer = await (0,_components_tokenizer_index_js__WEBPACK_IMPORTED_MODULE_4__.createTokenizer)({
            language: language ?? 'english'
        });
    } else if (!tokenizer.tokenize) {
        // If there is no tokenizer function, we assume this is a TokenizerConfig
        tokenizer = await (0,_components_tokenizer_index_js__WEBPACK_IMPORTED_MODULE_4__.createTokenizer)(tokenizer);
    } else {
        const customTokenizer = tokenizer;
        tokenizer = customTokenizer;
    }
    if (components.tokenizer && language) {
        // Accept language only if a tokenizer is not provided
        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_3__.createError)('NO_LANGUAGE_WITH_CUSTOM_TOKENIZER');
    }
    const internalDocumentStore = (0,_components_internal_document_id_store_js__WEBPACK_IMPORTED_MODULE_5__.createInternalDocumentIDStore)();
    index ||= await (0,_components_index_js__WEBPACK_IMPORTED_MODULE_6__.createIndex)();
    sorter ||= await (0,_components_sorter_js__WEBPACK_IMPORTED_MODULE_7__.createSorter)();
    documentsStore ||= await (0,_components_documents_store_js__WEBPACK_IMPORTED_MODULE_8__.createDocumentsStore)();
    // Validate all other components
    validateComponents(components);
    // Assign only recognized components and hooks
    const { getDocumentProperties , getDocumentIndexId , validateSchema , formatElapsedTime  } = components;
    const orama = {
        data: {},
        caches: {},
        schema,
        tokenizer,
        index,
        sorter,
        documentsStore,
        internalDocumentIDStore: internalDocumentStore,
        getDocumentProperties,
        getDocumentIndexId,
        validateSchema,
        beforeInsert: [],
        afterInsert: [],
        beforeRemove: [],
        afterRemove: [],
        beforeUpdate: [],
        afterUpdate: [],
        beforeSearch: [],
        afterSearch: [],
        beforeInsertMultiple: [],
        afterInsertMultiple: [],
        beforeRemoveMultiple: [],
        afterRemoveMultiple: [],
        afterUpdateMultiple: [],
        beforeUpdateMultiple: [],
        afterCreate: [],
        formatElapsedTime,
        id,
        plugins,
        version: getVersion()
    };
    orama.data = {
        index: await orama.index.create(orama, internalDocumentStore, schema),
        docs: await orama.documentsStore.create(orama, internalDocumentStore),
        sorting: await orama.sorter.create(orama, internalDocumentStore, schema, sort)
    };
    for (const hook of _components_plugins_js__WEBPACK_IMPORTED_MODULE_9__.AVAILABLE_PLUGIN_HOOKS){
        orama[hook] = (orama[hook] ?? []).concat(await (0,_components_plugins_js__WEBPACK_IMPORTED_MODULE_9__.getAllPluginsByHook)(orama, hook));
    }
    const afterCreate = orama['afterCreate'];
    if (afterCreate) {
        await (0,_components_hooks_js__WEBPACK_IMPORTED_MODULE_2__.runAfterCreate)(afterCreate, orama);
    }
    return orama;
}
function getVersion() {
    return '2.0.21';
}

//# sourceMappingURL=create.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/methods/insert.js":
/*!**********************************************************!*\
  !*** ./node_modules/@orama/orama/dist/methods/insert.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   innerInsertMultiple: () => (/* binding */ innerInsertMultiple),
/* harmony export */   insert: () => (/* binding */ insert),
/* harmony export */   insertMultiple: () => (/* binding */ insertMultiple)
/* harmony export */ });
/* harmony import */ var _components_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components.js */ "./node_modules/@orama/orama/dist/components/defaults.js");
/* harmony import */ var _components_hooks_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/hooks.js */ "./node_modules/@orama/orama/dist/components/hooks.js");
/* harmony import */ var _components_sync_blocking_checker_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/sync-blocking-checker.js */ "./node_modules/@orama/orama/dist/components/sync-blocking-checker.js");
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors.js */ "./node_modules/@orama/orama/dist/errors.js");




async function insert(orama, doc, language, skipHooks) {
    const errorProperty = await orama.validateSchema(doc, orama.schema);
    if (errorProperty) {
        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.createError)('SCHEMA_VALIDATION_FAILURE', errorProperty);
    }
    return innerInsert(orama, doc, language, skipHooks);
}
const ENUM_TYPE = new Set([
    'enum',
    'enum[]'
]);
const STRING_NUMBER_TYPE = new Set([
    'string',
    'number'
]);
async function innerInsert(orama, doc, language, skipHooks) {
    const { index , docs  } = orama.data;
    const id = await orama.getDocumentIndexId(doc);
    if (typeof id !== 'string') {
        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.createError)('DOCUMENT_ID_MUST_BE_STRING', typeof id);
    }
    if (!await orama.documentsStore.store(docs, id, doc)) {
        throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.createError)('DOCUMENT_ALREADY_EXISTS', id);
    }
    const docsCount = await orama.documentsStore.count(docs);
    if (!skipHooks) {
        await (0,_components_hooks_js__WEBPACK_IMPORTED_MODULE_1__.runSingleHook)(orama.beforeInsert, orama, id, doc);
    }
    const indexableProperties = await orama.index.getSearchableProperties(index);
    const indexablePropertiesWithTypes = await orama.index.getSearchablePropertiesWithTypes(index);
    const indexableValues = await orama.getDocumentProperties(doc, indexableProperties);
    for (const [key, value] of Object.entries(indexableValues)){
        if (typeof value === 'undefined') {
            continue;
        }
        const actualType = typeof value;
        const expectedType = indexablePropertiesWithTypes[key];
        if ((0,_components_js__WEBPACK_IMPORTED_MODULE_2__.isGeoPointType)(expectedType) && typeof value === 'object' && typeof value.lon === 'number' && typeof value.lat === 'number') {
            continue;
        }
        if ((0,_components_js__WEBPACK_IMPORTED_MODULE_2__.isVectorType)(expectedType) && Array.isArray(value)) {
            continue;
        }
        if ((0,_components_js__WEBPACK_IMPORTED_MODULE_2__.isArrayType)(expectedType) && Array.isArray(value)) {
            continue;
        }
        if (ENUM_TYPE.has(expectedType) && STRING_NUMBER_TYPE.has(actualType)) {
            continue;
        }
        if (actualType !== expectedType) {
            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.createError)('INVALID_DOCUMENT_PROPERTY', key, expectedType, actualType);
        }
    }
    for (const prop of indexableProperties){
        var _orama_index, _orama_index_beforeInsert, _orama_index1, _orama_index_afterInsert;
        const value = indexableValues[prop];
        if (typeof value === 'undefined') {
            continue;
        }
        const expectedType = indexablePropertiesWithTypes[prop];
        await ((_orama_index_beforeInsert = (_orama_index = orama.index).beforeInsert) === null || _orama_index_beforeInsert === void 0 ? void 0 : _orama_index_beforeInsert.call(_orama_index, orama.data.index, prop, id, value, expectedType, language, orama.tokenizer, docsCount));
        await orama.index.insert(orama.index, orama.data.index, prop, id, value, expectedType, language, orama.tokenizer, docsCount);
        await ((_orama_index_afterInsert = (_orama_index1 = orama.index).afterInsert) === null || _orama_index_afterInsert === void 0 ? void 0 : _orama_index_afterInsert.call(_orama_index1, orama.data.index, prop, id, value, expectedType, language, orama.tokenizer, docsCount));
    }
    const sortableProperties = await orama.sorter.getSortableProperties(orama.data.sorting);
    const sortablePropertiesWithTypes = await orama.sorter.getSortablePropertiesWithTypes(orama.data.sorting);
    const sortableValues = await orama.getDocumentProperties(doc, sortableProperties);
    for (const prop of sortableProperties){
        const value = sortableValues[prop];
        if (typeof value === 'undefined') {
            continue;
        }
        const expectedType = sortablePropertiesWithTypes[prop];
        await orama.sorter.insert(orama.data.sorting, prop, id, value, expectedType, language);
    }
    if (!skipHooks) {
        await (0,_components_hooks_js__WEBPACK_IMPORTED_MODULE_1__.runSingleHook)(orama.afterInsert, orama, id, doc);
    }
    (0,_components_sync_blocking_checker_js__WEBPACK_IMPORTED_MODULE_3__.trackInsertion)(orama);
    return id;
}
async function insertMultiple(orama, docs, batchSize, language, skipHooks, timeout) {
    if (!skipHooks) {
        await (0,_components_hooks_js__WEBPACK_IMPORTED_MODULE_1__.runMultipleHook)(orama.beforeInsertMultiple, orama, docs);
    }
    // Validate all documents before the insertion
    const docsLength = docs.length;
    const oramaSchema = orama.schema;
    for(let i = 0; i < docsLength; i++){
        const errorProperty = await orama.validateSchema(docs[i], oramaSchema);
        if (errorProperty) {
            throw (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.createError)('SCHEMA_VALIDATION_FAILURE', errorProperty);
        }
    }
    return innerInsertMultiple(orama, docs, batchSize, language, skipHooks, timeout);
}
async function innerInsertMultiple(orama, docs, batchSize, language, skipHooks, timeout) {
    if (!batchSize) {
        batchSize = 1000;
    }
    timeout ??= 0;
    const ids = [];
    await new Promise((resolve, reject)=>{
        let i = 0;
        async function _insertMultiple() {
            const batch = docs.slice(i * batchSize, ++i * batchSize);
            if (!batch.length) {
                return resolve();
            }
            for (const doc of batch){
                try {
                    const id = await insert(orama, doc, language, skipHooks);
                    ids.push(id);
                } catch (err) {
                    reject(err);
                }
            }
            setTimeout(_insertMultiple, timeout);
        }
        setTimeout(_insertMultiple, timeout);
    });
    if (!skipHooks) {
        await (0,_components_hooks_js__WEBPACK_IMPORTED_MODULE_1__.runMultipleHook)(orama.afterInsertMultiple, orama, docs);
    }
    return ids;
}

//# sourceMappingURL=insert.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/trees/avl.js":
/*!*****************************************************!*\
  !*** ./node_modules/@orama/orama/dist/trees/avl.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   contains: () => (/* binding */ contains),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   find: () => (/* binding */ find),
/* harmony export */   getSize: () => (/* binding */ getSize),
/* harmony export */   greaterThan: () => (/* binding */ greaterThan),
/* harmony export */   insert: () => (/* binding */ insert),
/* harmony export */   isBalanced: () => (/* binding */ isBalanced),
/* harmony export */   lessThan: () => (/* binding */ lessThan),
/* harmony export */   rangeSearch: () => (/* binding */ rangeSearch),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   removeDocument: () => (/* binding */ removeDocument)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/@orama/orama/dist/utils.js");

function rotateLeft(node) {
    const right = node.r;
    node.r = right.l;
    right.l = node;
    node.h = Math.max(getHeight(node.l), getHeight(node.r)) + 1;
    right.h = Math.max(getHeight(right.l), getHeight(right.r)) + 1;
    return right;
}
function rotateRight(node) {
    const left = node.l;
    node.l = left.r;
    left.r = node;
    node.h = Math.max(getHeight(node.l), getHeight(node.r)) + 1;
    left.h = Math.max(getHeight(left.l), getHeight(left.r)) + 1;
    return left;
}
function contains(node, key) {
    return !!find(node, key);
}
function getSize(root) {
    let size = 0;
    const queue = [];
    if (root !== null) {
        queue.push(root.root);
    }
    while(queue.length > 0){
        const node = queue.shift();
        size++;
        if (node.l !== null) {
            queue.push(node.l);
        }
        if (node.r !== null) {
            queue.push(node.r);
        }
    }
    return size;
}
function isBalanced(root) {
    if (root === null) return true;
    const stack = [
        root.root
    ];
    while(stack.length > 0){
        const node = stack.pop();
        if (node != null) {
            const leftHeight = getHeight(node.l);
            const rightHeight = getHeight(node.r);
            const heightDiff = leftHeight - rightHeight;
            if (Math.abs(heightDiff) > 1) {
                return false;
            }
            if (node.l !== null) {
                stack.push(node.l);
            }
            if (node.r !== null) {
                stack.push(node.r);
            }
        }
    }
    return true;
}
function rangeSearch(node, min, max) {
    const result = [];
    function traverse(node) {
        if (node === null) {
            return;
        }
        if (min < node.k) {
            traverse(node.l);
        }
        if (node.k >= min && node.k <= max) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.safeArrayPush)(result, node.v);
        }
        if (max > node.k) {
            traverse(node.r);
        }
    }
    traverse(node.root);
    return result;
}
function greaterThan(node, key, inclusive = false) {
    const result = [];
    if (node === null) return result;
    const stack = [
        node.root
    ];
    while(stack.length > 0){
        const node = stack.pop();
        if (!node) {
            continue;
        }
        if (inclusive && node.k >= key) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.safeArrayPush)(result, node.v);
        }
        if (!inclusive && node.k > key) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.safeArrayPush)(result, node.v);
        }
        stack.push(node.r);
        stack.push(node.l);
    }
    return result;
}
function lessThan(node, key, inclusive = false) {
    const result = [];
    if (node === null) return result;
    const stack = [
        node.root
    ];
    while(stack.length > 0){
        const node = stack.pop();
        if (!node) {
            continue;
        }
        if (inclusive && node.k <= key) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.safeArrayPush)(result, node.v);
        }
        if (!inclusive && node.k < key) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.safeArrayPush)(result, node.v);
        }
        stack.push(node.r);
        stack.push(node.l);
    }
    return result;
}
function getNodeByKey(node, key) {
    while(node !== null){
        if (key < node.k) {
            node = node.l;
        } else if (key > node.k) {
            node = node.r;
        } else {
            return node;
        }
    }
    return null;
}
function create(key, value) {
    return {
        root: {
            k: key,
            v: value,
            l: null,
            r: null,
            h: 0
        }
    };
}
function insert(rootNode, key, newValue) {
    function insertNode(node, key, newValue) {
        if (node === null) {
            return {
                k: key,
                v: newValue,
                l: null,
                r: null,
                h: 0
            };
        }
        if (key < node.k) {
            node.l = insertNode(node.l, key, newValue);
        } else if (key > node.k) {
            node.r = insertNode(node.r, key, newValue);
        } else {
            for (const value of newValue){
                node.v.push(value);
            }
            return node;
        }
        node.h = 1 + Math.max(getHeight(node.l), getHeight(node.r));
        const balanceFactor = getHeight(node.l) - getHeight(node.r);
        if (balanceFactor > 1 && key < node.l.k) {
            return rotateRight(node);
        }
        if (balanceFactor < -1 && key > node.r.k) {
            return rotateLeft(node);
        }
        if (balanceFactor > 1 && key > node.l.k) {
            node.l = rotateLeft(node.l);
            return rotateRight(node);
        }
        if (balanceFactor < -1 && key < node.r.k) {
            node.r = rotateRight(node.r);
            return rotateLeft(node);
        }
        return node;
    }
    rootNode.root = insertNode(rootNode.root, key, newValue);
}
function getHeight(node) {
    return node !== null ? node.h : -1;
}
function find(root, key) {
    const node = getNodeByKey(root.root, key);
    if (node === null) {
        return null;
    }
    return node.v;
}
function remove(rootNode, key) {
    if (rootNode === null || rootNode.root === null) {
        return;
    }
    let node = rootNode.root;
    let parentNode = null;
    while(node != null && node.k !== key){
        parentNode = node;
        if (key < node.k) {
            node = node.l;
        } else {
            node = node.r;
        }
    }
    if (node === null) {
        return;
    }
    const deleteNode = ()=>{
        if (node.l === null && node.r === null) {
            if (parentNode === null) {
                rootNode.root = null;
            } else {
                if (parentNode.l === node) {
                    parentNode.l = null;
                } else {
                    parentNode.r = null;
                }
            }
        } else if (node.l != null && node.r != null) {
            let minValueNode = node.r;
            let minValueParent = node;
            while(minValueNode.l != null){
                minValueParent = minValueNode;
                minValueNode = minValueNode.l;
            }
            node.k = minValueNode.k;
            if (minValueParent === node) {
                minValueParent.r = minValueNode.r;
            } else {
                minValueParent.l = minValueNode.r;
            }
        } else {
            const childNode = node.l != null ? node.l : node.r;
            if (parentNode === null) {
                rootNode.root = childNode;
            } else {
                if (parentNode.l === node) {
                    parentNode.l = childNode;
                } else {
                    parentNode.r = childNode;
                }
            }
        }
    };
    deleteNode();
}
function removeDocument(root, id, key) {
    const node = getNodeByKey(root.root, key);
    if (!node) {
        return;
    }
    if (node.v.length === 1) {
        remove(root, key);
        return;
    }
    node.v.splice(node.v.indexOf(id), 1);
}

//# sourceMappingURL=avl.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/trees/bkd.js":
/*!*****************************************************!*\
  !*** ./node_modules/@orama/orama/dist/trees/bkd.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   contains: () => (/* binding */ contains),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   getDocIDsByCoordinates: () => (/* binding */ getDocIDsByCoordinates),
/* harmony export */   insert: () => (/* binding */ insert),
/* harmony export */   removeDocByID: () => (/* binding */ removeDocByID),
/* harmony export */   searchByPolygon: () => (/* binding */ searchByPolygon),
/* harmony export */   searchByRadius: () => (/* binding */ searchByRadius)
/* harmony export */ });
const K = 2 // 2D points
;
const EARTH_RADIUS = 6371e3 // Earth radius in meters
;
function create() {
    return {
        root: null
    };
}
function insert(tree, point, docIDs) {
    const newNode = {
        point,
        docIDs
    };
    if (tree.root == null) {
        tree.root = newNode;
        return;
    }
    let node = tree.root;
    let depth = 0;
    while(node !== null){
        // Check if the current node's point matches the new point
        if (node.point.lon === point.lon && node.point.lat === point.lat) {
            // Merge the new docIDs with the existing ones and remove duplicates
            const newDocIDs = node.docIDs ?? [];
            node.docIDs = Array.from(new Set([
                ...newDocIDs,
                ...docIDs || []
            ]));
            return;
        }
        const axis = depth % K;
        // Compare by longitude
        if (axis === 0) {
            if (point.lon < node.point.lon) {
                if (node.left == null) {
                    node.left = newNode;
                    return;
                }
                node = node.left;
            } else {
                if (node.right == null) {
                    node.right = newNode;
                    return;
                }
                node = node.right;
            }
        // Compare by latitude
        } else {
            if (point.lat < node.point.lat) {
                if (node.left == null) {
                    node.left = newNode;
                    return;
                }
                node = node.left;
            } else {
                if (node.right == null) {
                    node.right = newNode;
                    return;
                }
                node = node.right;
            }
        }
        depth++;
    }
}
function contains(tree, point) {
    let node = tree.root;
    let depth = 0;
    while(node != null){
        if ((node === null || node === void 0 ? void 0 : node.point.lon) === point.lon && node.point.lat === point.lat) {
            return true;
        }
        const axis = depth % K;
        // Compare by longitude
        if (axis === 0) {
            if (point.lon < node.point.lon) {
                node = node === null || node === void 0 ? void 0 : node.left;
            } else {
                node = node === null || node === void 0 ? void 0 : node.right;
            }
        // Compare by latitude
        } else {
            if (point.lat < node.point.lat) {
                node = node === null || node === void 0 ? void 0 : node.left;
            } else {
                node = node === null || node === void 0 ? void 0 : node.right;
            }
        }
        depth++;
    }
    return false;
}
// @todo: this is very inefficient. Fix this later.
function removeDocByID(tree, point, docID) {
    let node = tree.root;
    let depth = 0;
    let parentNode = null;
    let direction = null;
    while(node !== null){
        if ((node === null || node === void 0 ? void 0 : node.point.lon) === point.lon && node.point.lat === point.lat) {
            var _node_docIDs;
            const index = (_node_docIDs = node.docIDs) === null || _node_docIDs === void 0 ? void 0 : _node_docIDs.indexOf(docID);
            if (index !== undefined && index > -1) {
                var // Remove the docID from the array
                _node_docIDs1;
                (_node_docIDs1 = node.docIDs) === null || _node_docIDs1 === void 0 ? void 0 : _node_docIDs1.splice(index, 1);
                if (node.docIDs == null || node.docIDs.length === 0) {
                    // If the node doesn't have any more docIDs, remove the node
                    if (parentNode != null) {
                        if (direction === 'left') {
                            parentNode.left = node.left !== null ? node.left : node.right;
                        } else if (direction === 'right') {
                            parentNode.right = node.right !== null ? node.right : node.left;
                        }
                    } else {
                        // If the node to be removed is the root
                        tree.root = node.left !== null ? node.left : node.right;
                    }
                }
                return;
            }
        }
        const axis = depth % K;
        parentNode = node;
        // Compare by longitude
        if (axis === 0) {
            if (point.lon < node.point.lon) {
                node = node === null || node === void 0 ? void 0 : node.left;
                direction = 'left';
            } else {
                node = node === null || node === void 0 ? void 0 : node.right;
                direction = 'right';
            }
        // Compare by latitude
        } else {
            if (point.lat < node.point.lat) {
                node = node === null || node === void 0 ? void 0 : node.left;
                direction = 'left';
            } else {
                node = node === null || node === void 0 ? void 0 : node.right;
                direction = 'right';
            }
        }
        depth++;
    }
}
function getDocIDsByCoordinates(tree, point) {
    let node = tree.root;
    let depth = 0;
    while(node !== null){
        if (node.point.lon === point.lon && node.point.lat === point.lat) {
            // prettier-ignore
            return node.docIDs ?? null;
        }
        const axis = depth % K;
        // Compare by longitude
        if (axis === 0) {
            if (point.lon < node.point.lon) {
                node = node.left;
            } else {
                node = node.right;
            }
        // Compare by latitude
        } else {
            if (point.lat < node.point.lat) {
                node = node.left;
            } else {
                node = node.right;
            }
        }
        depth++;
    }
    return null;
}
function searchByRadius(node, center, radius, inclusive = true, sort = 'asc', highPrecision = false) {
    const distanceFn = highPrecision ? vincentyDistance : haversineDistance;
    const stack = [
        {
            node,
            depth: 0
        }
    ];
    const result = [];
    while(stack.length > 0){
        const { node , depth  } = stack.pop();
        if (node === null) continue;
        const dist = distanceFn(center, node.point);
        if (inclusive ? dist <= radius : dist > radius) {
            result.push({
                point: node.point,
                docIDs: node.docIDs ?? []
            });
        }
        if (node.left != null) {
            stack.push({
                node: node.left,
                depth: depth + 1
            });
        }
        if (node.right != null) {
            stack.push({
                node: node.right,
                depth: depth + 1
            });
        }
    }
    if (sort) {
        result.sort((a, b)=>{
            const distA = distanceFn(center, a.point);
            const distB = distanceFn(center, b.point);
            return sort.toLowerCase() === 'asc' ? distA - distB : distB - distA;
        });
    }
    return result;
}
function searchByPolygon(root, polygon, inclusive = true, sort = null, highPrecision = false) {
    const stack = [
        {
            node: root,
            depth: 0
        }
    ];
    const result = [];
    while(stack.length > 0){
        const task = stack.pop();
        if (task == null || task.node == null) continue;
        const { node , depth  } = task;
        const nextDepth = depth + 1;
        if (node.left != null) {
            stack.push({
                node: node.left,
                depth: nextDepth
            });
        }
        if (node.right != null) {
            stack.push({
                node: node.right,
                depth: nextDepth
            });
        }
        const isInsidePolygon = isPointInPolygon(polygon, node.point);
        if (isInsidePolygon && inclusive) {
            result.push({
                point: node.point,
                docIDs: node.docIDs ?? []
            });
        } else if (!isInsidePolygon && !inclusive) {
            result.push({
                point: node.point,
                docIDs: node.docIDs ?? []
            });
        }
    }
    const centroid = calculatePolygonCentroid(polygon);
    if (sort) {
        const sortFn = highPrecision ? vincentyDistance : haversineDistance;
        result.sort((a, b)=>{
            const distA = sortFn(centroid, a.point);
            const distB = sortFn(centroid, b.point);
            return sort.toLowerCase() === 'asc' ? distA - distB : distB - distA;
        });
    }
    return result;
}
function calculatePolygonCentroid(polygon) {
    let totalArea = 0;
    let centroidX = 0;
    let centroidY = 0;
    const polygonLength = polygon.length;
    for(let i = 0, j = polygonLength - 1; i < polygonLength; j = i++){
        const xi = polygon[i].lon;
        const yi = polygon[i].lat;
        const xj = polygon[j].lon;
        const yj = polygon[j].lat;
        const areaSegment = xi * yj - xj * yi;
        totalArea += areaSegment;
        centroidX += (xi + xj) * areaSegment;
        centroidY += (yi + yj) * areaSegment;
    }
    totalArea /= 2;
    const centroidCoordinate = 6 * totalArea;
    centroidX /= centroidCoordinate;
    centroidY /= centroidCoordinate;
    return {
        lon: centroidX,
        lat: centroidY
    };
}
function isPointInPolygon(polygon, point) {
    let isInside = false;
    const x = point.lon;
    const y = point.lat;
    const polygonLength = polygon.length;
    for(let i = 0, j = polygonLength - 1; i < polygonLength; j = i++){
        const xi = polygon[i].lon;
        const yi = polygon[i].lat;
        const xj = polygon[j].lon;
        const yj = polygon[j].lat;
        const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        if (intersect) isInside = !isInside;
    }
    return isInside;
}
function haversineDistance(coord1, coord2) {
    const P = Math.PI / 180;
    const lat1 = coord1.lat * P;
    const lat2 = coord2.lat * P;
    const deltaLat = (coord2.lat - coord1.lat) * P;
    const deltaLon = (coord2.lon - coord1.lon) * P;
    const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return EARTH_RADIUS * c;
}
function vincentyDistance(coord1, coord2) {
    // Constants for WGS 84 ellipsoidal Earth model (https://epsg.org/ellipsoid_7030/WGS-84.html)
    // Semi-major axis of the Earth in meters
    const a = 6378137;
    // Flattening of the ellipsoid
    const f = 1 / 298.257223563;
    // Semi-minor axis
    const b = (1 - f) * a;
    // Convert degrees to radians for calculations
    const P = Math.PI / 180;
    const lat1 = coord1.lat * P;
    const lat2 = coord2.lat * P;
    const deltaLon = (coord2.lon - coord1.lon) * P;
    // Reduced latitudes - account for flattening by transforming from geodetic to auxiliary latitude
    const U1 = Math.atan((1 - f) * Math.tan(lat1));
    const U2 = Math.atan((1 - f) * Math.tan(lat2));
    const sinU1 = Math.sin(U1);
    const cosU1 = Math.cos(U1);
    const sinU2 = Math.sin(U2);
    const cosU2 = Math.cos(U2);
    // Initial approximation for the longitude difference between the two points
    let lambda = deltaLon;
    let prevLambda;
    // Limit the iterations to ensure we don't get stuck in an infinite loop
    let iterationLimit = 1000;
    let sinAlpha;
    let cos2Alpha;
    let sinSigma;
    let cosSigma;
    let sigma;
    // Refine the value of lambda (longitude difference)
    do {
        const sinLambda = Math.sin(lambda);
        const cosLambda = Math.cos(lambda);
        // Compute the trigonometric values required for Vincenty formulae
        sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
        sigma = Math.atan2(sinSigma, cosSigma);
        // Angular separation between the two points and the equator
        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;
        cos2Alpha = 1 - sinAlpha * sinAlpha;
        const cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cos2Alpha;
        // Compensation factor for the Earth's shape
        const C = f / 16 * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));
        // Store previous lambda to check for convergence
        prevLambda = lambda;
        // Refine the estimate of lambda using the Vincenty formula
        lambda = deltaLon + (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
    }while (Math.abs(lambda - prevLambda) > 1e-12 && --iterationLimit > 0)
    // Compute factors that depend on the shape of the Earth and angular distances
    const u2 = cos2Alpha * (a * a - b * b) / (b * b);
    const A = 1 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));
    const B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));
    // Compute the correction factor for the ellipsoidal shape of the Earth
    const deltaSigma = B * sinSigma * (cosSigma - 2 * sinU1 * sinU2 / cos2Alpha + B / 4 * (cosSigma * (-1 + 2 * sinSigma * sinSigma) - B / 6 * sigma * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * sigma * sigma)));
    // Final calculation of distance using Vincenty formula
    const s = b * A * (sigma - deltaSigma);
    return s;
}

//# sourceMappingURL=bkd.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/trees/flat.js":
/*!******************************************************!*\
  !*** ./node_modules/@orama/orama/dist/trees/flat.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   contains: () => (/* binding */ contains),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   filter: () => (/* binding */ filter),
/* harmony export */   filterArr: () => (/* binding */ filterArr),
/* harmony export */   find: () => (/* binding */ find),
/* harmony export */   getSize: () => (/* binding */ getSize),
/* harmony export */   insert: () => (/* binding */ insert),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   removeDocument: () => (/* binding */ removeDocument)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/@orama/orama/dist/utils.js");

function create() {
    return {
        numberToDocumentId: new Map()
    };
}
function insert(root, key, value) {
    if (root.numberToDocumentId.has(key)) {
        root.numberToDocumentId.get(key).push(value);
        return root;
    }
    root.numberToDocumentId.set(key, [
        value
    ]);
    return root;
}
function find(root, key) {
    return root.numberToDocumentId.get(key) ?? null;
}
function remove(root, key) {
    if (root != null) {
        root.numberToDocumentId.delete(key);
    }
    return root;
}
function removeDocument(root, id, key) {
    var _root_numberToDocumentId_get, _root_numberToDocumentId_get1;
    root === null || root === void 0 ? void 0 : root.numberToDocumentId.set(key, ((_root_numberToDocumentId_get = root === null || root === void 0 ? void 0 : root.numberToDocumentId.get(key)) === null || _root_numberToDocumentId_get === void 0 ? void 0 : _root_numberToDocumentId_get.filter((v)=>v !== id)) ?? []);
    if (((_root_numberToDocumentId_get1 = root === null || root === void 0 ? void 0 : root.numberToDocumentId.get(key)) === null || _root_numberToDocumentId_get1 === void 0 ? void 0 : _root_numberToDocumentId_get1.length) === 0) {
        root === null || root === void 0 ? void 0 : root.numberToDocumentId.delete(key);
    }
}
function contains(node, key) {
    return !(find(node, key) == null);
}
function getSize(root) {
    let size = 0;
    for (const [, value] of (root === null || root === void 0 ? void 0 : root.numberToDocumentId) ?? []){
        size += value.length;
    }
    return size;
}
function filter(root, operation) {
    const operationKeys = Object.keys(operation);
    if (operationKeys.length !== 1) {
        throw new Error('Invalid operation');
    }
    const operationType = operationKeys[0];
    switch(operationType){
        case 'eq':
            {
                const value = operation[operationType];
                return root.numberToDocumentId.get(value) ?? [];
            }
        case 'in':
            {
                const value = operation[operationType];
                const result = [];
                for (const v of value){
                    const ids = root.numberToDocumentId.get(v);
                    if (ids != null) {
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.safeArrayPush)(result, ids);
                    }
                }
                return result;
            }
        case 'nin':
            {
                const value = operation[operationType];
                const result = [];
                const keys = root.numberToDocumentId.keys();
                for (const key of keys){
                    if (value.includes(key)) {
                        continue;
                    }
                    const ids = root.numberToDocumentId.get(key);
                    if (ids != null) {
                        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.safeArrayPush)(result, ids);
                    }
                }
                return result;
            }
    }
    throw new Error('Invalid operation');
}
function filterArr(root, operation) {
    const operationKeys = Object.keys(operation);
    if (operationKeys.length !== 1) {
        throw new Error('Invalid operation');
    }
    const operationType = operationKeys[0];
    switch(operationType){
        case 'containsAll':
            {
                const values = operation[operationType];
                const ids = values.map((value)=>root.numberToDocumentId.get(value) ?? []);
                return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.intersect)(ids);
            }
    }
    throw new Error('Invalid operation');
}

//# sourceMappingURL=flat.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/trees/radix.js":
/*!*******************************************************!*\
  !*** ./node_modules/@orama/orama/dist/trees/radix.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Node: () => (/* binding */ Node),
/* harmony export */   contains: () => (/* binding */ contains),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   find: () => (/* binding */ find),
/* harmony export */   insert: () => (/* binding */ insert),
/* harmony export */   removeDocumentByWord: () => (/* binding */ removeDocumentByWord),
/* harmony export */   removeWord: () => (/* binding */ removeWord)
/* harmony export */ });
/* harmony import */ var _components_levenshtein_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/levenshtein.js */ "./node_modules/@orama/orama/dist/components/levenshtein.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/@orama/orama/dist/utils.js");


class Node {
    constructor(key, subWord, end){
        this.k = key;
        this.s = subWord;
        this.e = end;
    }
    // Node children
    c = {};
    // Node documents
    d = [];
    // Node word
    w = '';
    toJSON() {
        return {
            w: this.w,
            s: this.s,
            c: this.c,
            d: this.d,
            e: this.e
        };
    }
}
function updateParent(node, parent) {
    node.w = parent.w + node.s;
}
function addDocument(node, docID) {
    node.d.push(docID);
}
function removeDocument(node, docID) {
    const index = node.d.indexOf(docID);
    /* c8 ignore next 3 */ if (index === -1) {
        return false;
    }
    node.d.splice(index, 1);
    return true;
}
function findAllWords(node, output, term, exact, tolerance) {
    if (node.e) {
        const { w , d: docIDs  } = node;
        if (exact && w !== term) {
            return {};
        }
        // always check in own property to prevent access to inherited properties
        // fix https://github.com/OramaSearch/orama/issues/137
        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getOwnProperty)(output, w) == null) {
            if (tolerance) {
                // computing the absolute difference of letters between the term and the word
                const difference = Math.abs(term.length - w.length);
                // if the tolerance is set, check whether the edit distance is within tolerance.
                // In that case, we don't need to add the word to the output
                if (difference <= tolerance && (0,_components_levenshtein_js__WEBPACK_IMPORTED_MODULE_1__.syncBoundedLevenshtein)(term, w, tolerance).isBounded) {
                    output[w] = [];
                }
            } else {
                // prevent default tolerance not set
                output[w] = [];
            }
        }
        // check if _output[w] exists and then add the doc to it
        // always check in own property to prevent access to inherited properties
        // fix https://github.com/OramaSearch/orama/issues/137
        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getOwnProperty)(output, w) != null && docIDs.length > 0) {
            const docs = new Set(output[w]);
            const docIDsLength = docIDs.length;
            for(let i = 0; i < docIDsLength; i++){
                docs.add(docIDs[i]);
            }
            output[w] = Array.from(docs);
        }
    }
    // recursively search the children
    for (const character of Object.keys(node.c)){
        findAllWords(node.c[character], output, term, exact, tolerance);
    }
    return output;
}
function getCommonPrefix(a, b) {
    let commonPrefix = '';
    const len = Math.min(a.length, b.length);
    for(let i = 0; i < len; i++){
        if (a[i] !== b[i]) {
            return commonPrefix;
        }
        commonPrefix += a[i];
    }
    return commonPrefix;
}
function create(end = false, subWord = '', key = '') {
    return new Node(key, subWord, end);
}
function insert(root, word, docId) {
    const wordLength = word.length;
    for(let i = 0; i < wordLength; i++){
        const currentCharacter = word[i];
        const wordAtIndex = word.substring(i);
        const rootChildCurrentChar = root.c[currentCharacter];
        if (rootChildCurrentChar) {
            const edgeLabel = rootChildCurrentChar.s;
            const edgeLabelLength = edgeLabel.length;
            const commonPrefix = getCommonPrefix(edgeLabel, wordAtIndex);
            const commonPrefixLength = commonPrefix.length;
            // the wordAtIndex matches exactly with an existing child node
            if (edgeLabel === wordAtIndex) {
                addDocument(rootChildCurrentChar, docId);
                rootChildCurrentChar.e = true;
                return;
            }
            const edgeLabelAtCommonPrefix = edgeLabel[commonPrefixLength];
            // the wordAtIndex is completely contained in the child node subword
            if (commonPrefixLength < edgeLabelLength && commonPrefixLength === wordAtIndex.length) {
                const newNode = create(true, wordAtIndex, currentCharacter) // Create a new node with end set to true
                ;
                newNode.c[edgeLabelAtCommonPrefix] = rootChildCurrentChar;
                const newNodeChild = newNode.c[edgeLabelAtCommonPrefix];
                newNodeChild.s = edgeLabel.substring(commonPrefixLength);
                newNodeChild.k = edgeLabelAtCommonPrefix;
                root.c[currentCharacter] = newNode;
                updateParent(newNode, root);
                updateParent(newNodeChild, newNode);
                addDocument(newNode, docId);
                return;
            }
            // the wordAtIndex is partially contained in the child node subword
            if (commonPrefixLength < edgeLabelLength && commonPrefixLength < wordAtIndex.length) {
                const inbetweenNode = create(false, commonPrefix, currentCharacter);
                inbetweenNode.c[edgeLabelAtCommonPrefix] = rootChildCurrentChar;
                root.c[currentCharacter] = inbetweenNode;
                const inbetweenNodeChild = inbetweenNode.c[edgeLabelAtCommonPrefix];
                inbetweenNodeChild.s = edgeLabel.substring(commonPrefixLength);
                inbetweenNodeChild.k = edgeLabelAtCommonPrefix;
                const wordAtCommonPrefix = wordAtIndex[commonPrefixLength];
                const newNode = create(true, word.substring(i + commonPrefixLength), wordAtCommonPrefix);
                addDocument(newNode, docId);
                inbetweenNode.c[wordAtCommonPrefix] = newNode;
                updateParent(inbetweenNode, root);
                updateParent(newNode, inbetweenNode);
                updateParent(inbetweenNodeChild, inbetweenNode);
                return;
            }
            // skip to the next divergent character
            i += edgeLabelLength - 1;
            // navigate in the child node
            root = rootChildCurrentChar;
        } else {
            // if the node for the current character doesn't exist create new node
            const newNode = create(true, wordAtIndex, currentCharacter);
            addDocument(newNode, docId);
            root.c[currentCharacter] = newNode;
            updateParent(newNode, root);
            return;
        }
    }
}
function _findLevenshtein(node, term, index, tolerance, originalTolerance, output) {
    if (tolerance < 0) {
        return;
    }
    if (node.w.startsWith(term)) {
        findAllWords(node, output, term, false, 0);
        return;
    }
    if (node.e) {
        const { w , d: docIDs  } = node;
        if (w) {
            if ((0,_components_levenshtein_js__WEBPACK_IMPORTED_MODULE_1__.syncBoundedLevenshtein)(term, w, originalTolerance).isBounded) {
                output[w] = [];
            }
            if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getOwnProperty)(output, w) != null && docIDs.length > 0) {
                const docs = new Set(output[w]);
                const docIDsLength = docIDs.length;
                for(let i = 0; i < docIDsLength; i++){
                    docs.add(docIDs[i]);
                }
                output[w] = Array.from(docs);
            }
        }
    }
    if (index >= term.length) {
        return;
    }
    // Match current character without consuming tolerance
    if (term[index] in node.c) {
        _findLevenshtein(node.c[term[index]], term, index + 1, tolerance, originalTolerance, output);
    }
    // If tolerance is still available, consider other branches:
    // 1. Deletion (skip the current term character)
    _findLevenshtein(node, term, index + 1, tolerance - 1, originalTolerance, output);
    // 2. Insertion (skip the current tree node character)
    for(const character in node.c){
        _findLevenshtein(node.c[character], term, index, tolerance - 1, originalTolerance, output);
    }
    // 3. Substitution (skip both current term character and tree node character)
    for(const character in node.c){
        if (character !== term[index]) {
            _findLevenshtein(node.c[character], term, index + 1, tolerance - 1, originalTolerance, output);
        }
    }
}
function find(root, { term , exact , tolerance  }) {
    // Find the closest node to the term
    // Use `if` condition because tolerance `0` is supposed to match only prefix.
    // (allows infinite insertions at end, which is against normal levenshtein logic).
    // (new _findLevenshtein only handles not exact and tolerance>0 condition)
    if (tolerance && !exact) {
        const output = {};
        tolerance = tolerance || 0;
        _findLevenshtein(root, term, 0, tolerance || 0, tolerance, output);
        return output;
    } else {
        const termLength = term.length;
        for(let i = 0; i < termLength; i++){
            const character = term[i];
            if (character in root.c) {
                const rootChildCurrentChar = root.c[character];
                const edgeLabel = rootChildCurrentChar.s;
                const termSubstring = term.substring(i);
                // find the common prefix between two words ex: prime and primate = prim
                const commonPrefix = getCommonPrefix(edgeLabel, termSubstring);
                const commonPrefixLength = commonPrefix.length;
                // if the common prefix length is equal to edgeLabel length (the node subword) it means they are a match
                // if the common prefix is equal to the term means it is contained in the node
                if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {
                    // if tolerance is set we take the current node as the closest
                    if (tolerance) break;
                    return {};
                }
                // skip the subword length and check the next divergent character
                i += rootChildCurrentChar.s.length - 1;
                // navigate into the child node
                root = rootChildCurrentChar;
            } else {
                return {};
            }
        }
        const output = {};
        // found the closest node we recursively search through children
        findAllWords(root, output, term, exact, tolerance);
        return output;
    }
}
function contains(root, term) {
    const termLength = term.length;
    for(let i = 0; i < termLength; i++){
        const character = term[i];
        if (character in root.c) {
            const rootChildrenChar = root.c[character];
            const edgeLabel = rootChildrenChar.s;
            const termSubstring = term.substring(i);
            const commonPrefix = getCommonPrefix(edgeLabel, termSubstring);
            const commonPrefixLength = commonPrefix.length;
            if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {
                return false;
            }
            i += rootChildrenChar.s.length - 1;
            root = rootChildrenChar;
        } else {
            return false;
        }
    }
    return true;
}
function removeWord(root, term) {
    if (!term) {
        return false;
    }
    const termLength = term.length;
    for(let i = 0; i < termLength; i++){
        const character = term[i];
        const parent = root;
        if (character in root.c) {
            i += root.c[character].s.length - 1;
            root = root.c[character];
            if (Object.keys(root.c).length === 0) {
                delete parent.c[root.k];
                return true;
            }
        } else {
            return false;
        }
    }
    return false;
}
function removeDocumentByWord(root, term, docID, exact = true) {
    if (!term) {
        return true;
    }
    const termLength = term.length;
    for(let i = 0; i < termLength; i++){
        const character = term[i];
        if (character in root.c) {
            const rootChildCurrentChar = root.c[character];
            i += rootChildCurrentChar.s.length - 1;
            root = rootChildCurrentChar;
            if (exact && root.w !== term) {
            // Do nothing if the exact condition is not met.
            } else {
                removeDocument(root, docID);
            }
        } else {
            return false;
        }
    }
    return true;
}

//# sourceMappingURL=radix.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/types.js":
/*!*************************************************!*\
  !*** ./node_modules/@orama/orama/dist/types.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MODE_FULLTEXT_SEARCH: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.MODE_FULLTEXT_SEARCH),
/* harmony export */   MODE_HYBRID_SEARCH: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.MODE_HYBRID_SEARCH),
/* harmony export */   MODE_VECTOR_SEARCH: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.MODE_VECTOR_SEARCH),
/* harmony export */   kInsertions: () => (/* binding */ kInsertions),
/* harmony export */   kRemovals: () => (/* binding */ kRemovals)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./node_modules/@orama/orama/dist/constants.js");

const kInsertions = Symbol('orama.insertions');
const kRemovals = Symbol('orama.removals');

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/@orama/orama/dist/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@orama/orama/dist/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MAX_ARGUMENT_FOR_STACK: () => (/* binding */ MAX_ARGUMENT_FOR_STACK),
/* harmony export */   convertDistanceToMeters: () => (/* binding */ convertDistanceToMeters),
/* harmony export */   flattenObject: () => (/* binding */ flattenObject),
/* harmony export */   formatBytes: () => (/* binding */ formatBytes),
/* harmony export */   formatNanoseconds: () => (/* binding */ formatNanoseconds),
/* harmony export */   getDocumentProperties: () => (/* binding */ getDocumentProperties),
/* harmony export */   getNanosecondTimeViaPerformance: () => (/* binding */ getNanosecondTimeViaPerformance),
/* harmony export */   getNanosecondsTime: () => (/* binding */ getNanosecondsTime),
/* harmony export */   getNested: () => (/* binding */ getNested),
/* harmony export */   getOwnProperty: () => (/* binding */ getOwnProperty),
/* harmony export */   getTokenFrequency: () => (/* binding */ getTokenFrequency),
/* harmony export */   insertSortedValue: () => (/* binding */ insertSortedValue),
/* harmony export */   intersect: () => (/* binding */ intersect),
/* harmony export */   isInsideNode: () => (/* binding */ isInsideNode),
/* harmony export */   isInsideWebWorker: () => (/* binding */ isInsideWebWorker),
/* harmony export */   isServer: () => (/* binding */ isServer),
/* harmony export */   removeVectorsFromHits: () => (/* binding */ removeVectorsFromHits),
/* harmony export */   safeArrayPush: () => (/* binding */ safeArrayPush),
/* harmony export */   sortTokenScorePredicate: () => (/* binding */ sortTokenScorePredicate),
/* harmony export */   sprintf: () => (/* binding */ sprintf),
/* harmony export */   uniqueId: () => (/* binding */ uniqueId)
/* harmony export */ });
/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ "./node_modules/@orama/orama/dist/errors.js");
/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ "./node_modules/process/browser.js");

const baseId = Date.now().toString().slice(5);
let lastId = 0;
const k = 1024;
const nano = BigInt(1e3);
const milli = BigInt(1e6);
const second = BigInt(1e9);
const isServer = typeof window === 'undefined';
/**
 * This value can be increased up to 100_000
 * But i don't know if this value change from nodejs to nodejs
 * So I will keep a safer value here.
 */ const MAX_ARGUMENT_FOR_STACK = 65535;
/**
 * This method is needed to used because of issues like: https://github.com/oramasearch/orama/issues/301
 * that issue is caused because the array that is pushed is huge (>100k)
 *
 * @example
 * ```ts
 * safeArrayPush(myArray, [1, 2])
 * ```
 */ function safeArrayPush(arr, newArr) {
    if (newArr.length < MAX_ARGUMENT_FOR_STACK) {
        Array.prototype.push.apply(arr, newArr);
    } else {
        const newArrLength = newArr.length;
        for(let i = 0; i < newArrLength; i += MAX_ARGUMENT_FOR_STACK){
            Array.prototype.push.apply(arr, newArr.slice(i, i + MAX_ARGUMENT_FOR_STACK));
        }
    }
}
function sprintf(template, ...args) {
    return template.replace(/%(?:(?<position>\d+)\$)?(?<width>-?\d*\.?\d*)(?<type>[dfs])/g, function(...replaceArgs) {
        const groups = replaceArgs[replaceArgs.length - 1];
        const { width: rawWidth , type , position  } = groups;
        const replacement = position ? args[Number.parseInt(position) - 1] : args.shift();
        const width = rawWidth === '' ? 0 : Number.parseInt(rawWidth);
        switch(type){
            case 'd':
                return replacement.toString().padStart(width, '0');
            case 'f':
                {
                    let value = replacement;
                    const [padding, precision] = rawWidth.split('.').map((w)=>Number.parseFloat(w));
                    if (typeof precision === 'number' && precision >= 0) {
                        value = value.toFixed(precision);
                    }
                    return typeof padding === 'number' && padding >= 0 ? value.toString().padStart(width, '0') : value.toString();
                }
            case 's':
                return width < 0 ? replacement.toString().padEnd(-width, ' ') : replacement.toString().padStart(width, ' ');
            default:
                return replacement;
        }
    });
}
async function formatBytes(bytes, decimals = 2) {
    if (bytes === 0) {
        return '0 Bytes';
    }
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = [
        'Bytes',
        'KB',
        'MB',
        'GB',
        'TB',
        'PB',
        'EB',
        'ZB',
        'YB'
    ];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
}
function isInsideWebWorker() {
    // @ts-expect-error - WebWorker global scope
    return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
}
function isInsideNode() {
    return typeof process !== 'undefined' && process.release && process.release.name === 'node';
}
function getNanosecondTimeViaPerformance() {
    return BigInt(Math.floor(performance.now() * 1e6));
}
async function formatNanoseconds(value) {
    if (typeof value === 'number') {
        value = BigInt(value);
    }
    if (value < nano) {
        return `${value}ns`;
    } else if (value < milli) {
        return `${value / nano}s`;
    } else if (value < second) {
        return `${value / milli}ms`;
    }
    return `${value / second}s`;
}
// TODO: none of these operations is async. Should we change the signature of this function?
async function getNanosecondsTime() {
    var _process_hrtime;
    if (isInsideWebWorker()) {
        return getNanosecondTimeViaPerformance();
    }
    if (isInsideNode()) {
        return process.hrtime.bigint();
    }
    if (typeof process !== 'undefined' && typeof (process === null || process === void 0 ? void 0 : (_process_hrtime = process.hrtime) === null || _process_hrtime === void 0 ? void 0 : _process_hrtime.bigint) === 'function') {
        return process.hrtime.bigint();
    }
    if (typeof performance !== 'undefined') {
        return getNanosecondTimeViaPerformance();
    }
    // @todo: fallback to V8 native method to get microtime
    return BigInt(0);
}
async function uniqueId() {
    return `${baseId}-${lastId++}`;
}
function getOwnProperty(object, property) {
    // Checks if `hasOwn` method is defined avoiding errors with older Node.js versions
    if (Object.hasOwn === undefined) {
        return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined;
    }
    return Object.hasOwn(object, property) ? object[property] : undefined;
}
function getTokenFrequency(token, tokens) {
    let count = 0;
    for (const t of tokens){
        if (t === token) {
            count++;
        }
    }
    return count;
}
function insertSortedValue(arr, el, compareFn = sortTokenScorePredicate) {
    let low = 0;
    let high = arr.length;
    let mid;
    while(low < high){
        mid = low + high >>> 1;
        if (compareFn(el, arr[mid]) < 0) {
            high = mid;
        } else {
            low = mid + 1;
        }
    }
    arr.splice(low, 0, el);
    return arr;
}
function sortTokenScorePredicate(a, b) {
    if (b[1] === a[1]) {
        return a[0] - b[0];
    }
    return b[1] - a[1];
}
// Intersection function taken from https://github.com/lovasoa/fast_array_intersect.
// MIT Licensed at the time of writing.
function intersect(arrays) {
    if (arrays.length === 0) {
        return [];
    } else if (arrays.length === 1) {
        return arrays[0];
    }
    for(let i = 1; i < arrays.length; i++){
        if (arrays[i].length < arrays[0].length) {
            const tmp = arrays[0];
            arrays[0] = arrays[i];
            arrays[i] = tmp;
        }
    }
    const set = new Map();
    for (const elem of arrays[0]){
        set.set(elem, 1);
    }
    for(let i = 1; i < arrays.length; i++){
        let found = 0;
        for (const elem of arrays[i]){
            const count = set.get(elem);
            if (count === i) {
                set.set(elem, count + 1);
                found++;
            }
        }
        if (found === 0) return [];
    }
    return arrays[0].filter((e)=>{
        const count = set.get(e);
        if (count !== undefined) set.set(e, 0);
        return count === arrays.length;
    });
}
async function getDocumentProperties(doc, paths) {
    const properties = {};
    const pathsLength = paths.length;
    for(let i = 0; i < pathsLength; i++){
        const path = paths[i];
        const pathTokens = path.split('.');
        let current = doc;
        const pathTokensLength = pathTokens.length;
        for(let j = 0; j < pathTokensLength; j++){
            current = current[pathTokens[j]];
            // We found an object but we were supposed to be done
            if (typeof current === 'object') {
                if (current !== null && 'lat' in current && 'lon' in current && typeof current.lat === 'number' && typeof current.lon === 'number') {
                    current = properties[path] = current;
                    break;
                } else if (!Array.isArray(current) && current !== null && j === pathTokensLength - 1) {
                    current = undefined;
                    break;
                }
            } else if ((current === null || typeof current !== 'object') && j < pathTokensLength - 1) {
                // We can't recurse anymore but we were supposed to
                current = undefined;
                break;
            }
        }
        if (typeof current !== 'undefined') {
            properties[path] = current;
        }
    }
    return properties;
}
async function getNested(obj, path) {
    const props = await getDocumentProperties(obj, [
        path
    ]);
    return props[path];
}
function flattenObject(obj, prefix = '') {
    const result = {};
    for(const key in obj){
        const prop = `${prefix}${key}`;
        const objKey = obj[key];
        if (typeof objKey === 'object' && objKey !== null) {
            Object.assign(result, flattenObject(objKey, `${prop}.`));
        } else {
            result[prop] = objKey;
        }
    }
    return result;
}
const mapDistanceToMeters = {
    cm: 0.01,
    m: 1,
    km: 1000,
    ft: 0.3048,
    yd: 0.9144,
    mi: 1609.344
};
function convertDistanceToMeters(distance, unit) {
    const ratio = mapDistanceToMeters[unit];
    if (ratio === undefined) {
        throw new Error((0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.createError)('INVALID_DISTANCE_SUFFIX', distance).message);
    }
    return distance * ratio;
}
function removeVectorsFromHits(searchResult, vectorProperties) {
    searchResult.hits = searchResult.hits.map((result)=>({
            ...result,
            document: {
                ...result.document,
                // Remove embeddings from the result
                ...vectorProperties.reduce((acc, prop)=>{
                    const path = prop.split('.');
                    const lastKey = path.pop();
                    let obj = acc;
                    for (const key of path){
                        obj[key] = obj[key] ?? {};
                        obj = obj[key];
                    }
                    obj[lastKey] = null;
                    return acc;
                }, result.document)
            }
        }));
}

//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/jotai/esm/react.mjs":
/*!******************************************!*\
  !*** ./node_modules/jotai/esm/react.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Provider: () => (/* binding */ Provider),
/* harmony export */   useAtom: () => (/* binding */ useAtom),
/* harmony export */   useAtomValue: () => (/* binding */ useAtomValue),
/* harmony export */   useSetAtom: () => (/* binding */ useSetAtom),
/* harmony export */   useStore: () => (/* binding */ useStore)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react?1a75");
/* harmony import */ var jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jotai/vanilla */ "./node_modules/jotai/esm/vanilla.mjs");
'use client';



const StoreContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(
  void 0
);
const useStore = (options) => {
  const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);
  return (options == null ? void 0 : options.store) || store || (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.getDefaultStore)();
};
const Provider = ({
  children,
  store
}) => {
  const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  if (!store && !storeRef.current) {
    storeRef.current = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.createStore)();
  }
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(
    StoreContext.Provider,
    {
      value: store || storeRef.current
    },
    children
  );
};

const isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === "function";
const use = react__WEBPACK_IMPORTED_MODULE_0__.use || ((promise) => {
  if (promise.status === "pending") {
    throw promise;
  } else if (promise.status === "fulfilled") {
    return promise.value;
  } else if (promise.status === "rejected") {
    throw promise.reason;
  } else {
    promise.status = "pending";
    promise.then(
      (v) => {
        promise.status = "fulfilled";
        promise.value = v;
      },
      (e) => {
        promise.status = "rejected";
        promise.reason = e;
      }
    );
    throw promise;
  }
});
function useAtomValue(atom, options) {
  const store = useStore(options);
  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(
    (prev) => {
      const nextValue = store.get(atom);
      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {
        return prev;
      }
      return [nextValue, store, atom];
    },
    void 0,
    () => [store.get(atom), store, atom]
  );
  let value = valueFromReducer;
  if (storeFromReducer !== store || atomFromReducer !== atom) {
    rerender();
    value = store.get(atom);
  }
  const delay = options == null ? void 0 : options.delay;
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const unsub = store.sub(atom, () => {
      if (typeof delay === "number") {
        setTimeout(rerender, delay);
        return;
      }
      rerender();
    });
    rerender();
    return unsub;
  }, [store, atom, delay]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value);
  return isPromiseLike(value) ? use(value) : value;
}

function useSetAtom(atom, options) {
  const store = useStore(options);
  const setAtom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(
    (...args) => {
      if (( false ? 0 : void 0) !== "production" && !("write" in atom)) {
        throw new Error("not writable atom");
      }
      return store.set(atom, ...args);
    },
    [store, atom]
  );
  return setAtom;
}

function useAtom(atom, options) {
  return [
    useAtomValue(atom, options),
    // We do wrong type assertion here, which results in throwing an error.
    useSetAtom(atom, options)
  ];
}




/***/ }),

/***/ "./node_modules/jotai/esm/vanilla.mjs":
/*!********************************************!*\
  !*** ./node_modules/jotai/esm/vanilla.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   atom: () => (/* binding */ atom),
/* harmony export */   createStore: () => (/* binding */ createStore),
/* harmony export */   getDefaultStore: () => (/* binding */ getDefaultStore)
/* harmony export */ });
let keyCount = 0;
function atom(read, write) {
  const key = `atom${++keyCount}`;
  const config = {
    toString: () => key
  };
  if (typeof read === "function") {
    config.read = read;
  } else {
    config.init = read;
    config.read = defaultRead;
    config.write = defaultWrite;
  }
  if (write) {
    config.write = write;
  }
  return config;
}
function defaultRead(get) {
  return get(this);
}
function defaultWrite(get, set, arg) {
  return set(
    this,
    typeof arg === "function" ? arg(get(this)) : arg
  );
}

const isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;
const hasInitialValue = (atom) => "init" in atom;
const isActuallyWritableAtom = (atom) => !!atom.write;
const cancelPromiseMap = /* @__PURE__ */ new WeakMap();
const registerCancelPromise = (promise, cancel) => {
  cancelPromiseMap.set(promise, cancel);
  promise.catch(() => {
  }).finally(() => cancelPromiseMap.delete(promise));
};
const cancelPromise = (promise, next) => {
  const cancel = cancelPromiseMap.get(promise);
  if (cancel) {
    cancelPromiseMap.delete(promise);
    cancel(next);
  }
};
const resolvePromise = (promise, value) => {
  promise.status = "fulfilled";
  promise.value = value;
};
const rejectPromise = (promise, e) => {
  promise.status = "rejected";
  promise.reason = e;
};
const isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === "function";
const isEqualAtomValue = (a, b) => !!a && "v" in a && "v" in b && Object.is(a.v, b.v);
const isEqualAtomError = (a, b) => !!a && "e" in a && "e" in b && Object.is(a.e, b.e);
const hasPromiseAtomValue = (a) => !!a && "v" in a && a.v instanceof Promise;
const isEqualPromiseAtomValue = (a, b) => "v" in a && "v" in b && a.v.orig && a.v.orig === b.v.orig;
const returnAtomValue = (atomState) => {
  if ("e" in atomState) {
    throw atomState.e;
  }
  return atomState.v;
};
const createStore$1 = () => {
  const atomStateMap = /* @__PURE__ */ new WeakMap();
  const mountedMap = /* @__PURE__ */ new WeakMap();
  const pendingStack = [];
  const pendingMap = /* @__PURE__ */ new WeakMap();
  let devListenersRev2;
  let mountedAtoms;
  if (( false ? 0 : void 0) !== "production") {
    devListenersRev2 = /* @__PURE__ */ new Set();
    mountedAtoms = /* @__PURE__ */ new Set();
  }
  const getAtomState = (atom) => atomStateMap.get(atom);
  const addPendingDependent = (atom, atomState) => {
    atomState.d.forEach((_, a) => {
      if (!pendingMap.has(a)) {
        const aState = getAtomState(a);
        pendingMap.set(a, [aState, /* @__PURE__ */ new Set()]);
        if (aState) {
          addPendingDependent(a, aState);
        }
      }
      pendingMap.get(a)[1].add(atom);
    });
  };
  const setAtomState = (atom, atomState) => {
    var _a;
    if (( false ? 0 : void 0) !== "production") {
      Object.freeze(atomState);
    }
    const prevAtomState = getAtomState(atom);
    atomStateMap.set(atom, atomState);
    (_a = pendingStack[pendingStack.length - 1]) == null ? void 0 : _a.add(atom);
    if (!pendingMap.has(atom)) {
      pendingMap.set(atom, [prevAtomState, /* @__PURE__ */ new Set()]);
      addPendingDependent(atom, atomState);
    }
    if (hasPromiseAtomValue(prevAtomState)) {
      const next = "v" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);
      if (prevAtomState.v !== next) {
        cancelPromise(prevAtomState.v, next);
      }
    }
  };
  const updateDependencies = (atom, nextAtomState, nextDependencies, keepPreviousDependencies) => {
    const dependencies = new Map(
      keepPreviousDependencies ? nextAtomState.d : null
    );
    let changed = false;
    nextDependencies.forEach((aState, a) => {
      if (!aState && isSelfAtom(atom, a)) {
        aState = nextAtomState;
      }
      if (aState) {
        dependencies.set(a, aState);
        if (nextAtomState.d.get(a) !== aState) {
          changed = true;
        }
      } else if (( false ? 0 : void 0) !== "production") {
        console.warn("[Bug] atom state not found");
      }
    });
    if (changed || nextAtomState.d.size !== dependencies.size) {
      nextAtomState.d = dependencies;
    }
  };
  const setAtomValue = (atom, value, nextDependencies, keepPreviousDependencies) => {
    const prevAtomState = getAtomState(atom);
    const nextAtomState = {
      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),
      v: value
    };
    if (nextDependencies) {
      updateDependencies(
        atom,
        nextAtomState,
        nextDependencies,
        keepPreviousDependencies
      );
    }
    if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {
      return prevAtomState;
    }
    if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {
      if (prevAtomState.d === nextAtomState.d) {
        return prevAtomState;
      } else {
        nextAtomState.v = prevAtomState.v;
      }
    }
    setAtomState(atom, nextAtomState);
    return nextAtomState;
  };
  const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise) => {
    if (isPromiseLike(valueOrPromise)) {
      let continuePromise;
      const updatePromiseDependencies = () => {
        const prevAtomState = getAtomState(atom);
        if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {
          return;
        }
        const nextAtomState = setAtomValue(
          atom,
          promise,
          nextDependencies
        );
        if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {
          mountDependencies(atom, nextAtomState, prevAtomState.d);
        }
      };
      const promise = new Promise((resolve, reject) => {
        let settled = false;
        valueOrPromise.then(
          (v) => {
            if (!settled) {
              settled = true;
              resolvePromise(promise, v);
              resolve(v);
              updatePromiseDependencies();
            }
          },
          (e) => {
            if (!settled) {
              settled = true;
              rejectPromise(promise, e);
              reject(e);
              updatePromiseDependencies();
            }
          }
        );
        continuePromise = (next) => {
          if (!settled) {
            settled = true;
            next.then(
              (v) => resolvePromise(promise, v),
              (e) => rejectPromise(promise, e)
            );
            resolve(next);
          }
        };
      });
      promise.orig = valueOrPromise;
      promise.status = "pending";
      registerCancelPromise(promise, (next) => {
        if (next) {
          continuePromise(next);
          abortPromise == null ? void 0 : abortPromise();
        }
      });
      return setAtomValue(atom, promise, nextDependencies, true);
    }
    return setAtomValue(atom, valueOrPromise, nextDependencies);
  };
  const setAtomError = (atom, error, nextDependencies) => {
    const prevAtomState = getAtomState(atom);
    const nextAtomState = {
      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),
      e: error
    };
    if (nextDependencies) {
      updateDependencies(atom, nextAtomState, nextDependencies);
    }
    if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {
      return prevAtomState;
    }
    setAtomState(atom, nextAtomState);
    return nextAtomState;
  };
  const readAtomState = (atom, force) => {
    const atomState = getAtomState(atom);
    if (!(force == null ? void 0 : force(atom)) && atomState) {
      if (mountedMap.has(atom)) {
        return atomState;
      }
      if (Array.from(atomState.d).every(([a, s]) => {
        if (a === atom) {
          return true;
        }
        const aState = readAtomState(a, force);
        return aState === s || isEqualAtomValue(aState, s);
      })) {
        return atomState;
      }
    }
    const nextDependencies = /* @__PURE__ */ new Map();
    let isSync = true;
    const getter = (a) => {
      if (isSelfAtom(atom, a)) {
        const aState2 = getAtomState(a);
        if (aState2) {
          nextDependencies.set(a, aState2);
          return returnAtomValue(aState2);
        }
        if (hasInitialValue(a)) {
          nextDependencies.set(a, void 0);
          return a.init;
        }
        throw new Error("no atom init");
      }
      const aState = readAtomState(a, force);
      nextDependencies.set(a, aState);
      return returnAtomValue(aState);
    };
    let controller;
    let setSelf;
    const options = {
      get signal() {
        if (!controller) {
          controller = new AbortController();
        }
        return controller.signal;
      },
      get setSelf() {
        if (( false ? 0 : void 0) !== "production" && !isActuallyWritableAtom(atom)) {
          console.warn("setSelf function cannot be used with read-only atom");
        }
        if (!setSelf && isActuallyWritableAtom(atom)) {
          setSelf = (...args) => {
            if (( false ? 0 : void 0) !== "production" && isSync) {
              console.warn("setSelf function cannot be called in sync");
            }
            if (!isSync) {
              return writeAtom(atom, ...args);
            }
          };
        }
        return setSelf;
      }
    };
    try {
      const valueOrPromise = atom.read(getter, options);
      return setAtomValueOrPromise(
        atom,
        valueOrPromise,
        nextDependencies,
        () => controller == null ? void 0 : controller.abort()
      );
    } catch (error) {
      return setAtomError(atom, error, nextDependencies);
    } finally {
      isSync = false;
    }
  };
  const readAtom = (atom) => returnAtomValue(readAtomState(atom));
  const recomputeDependents = (atom) => {
    const getDependents = (a) => {
      var _a, _b;
      const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);
      (_b = pendingMap.get(a)) == null ? void 0 : _b[1].forEach((dependent) => {
        dependents.add(dependent);
      });
      return dependents;
    };
    const topsortedAtoms = new Array();
    const markedAtoms = /* @__PURE__ */ new Set();
    const visit = (n) => {
      if (markedAtoms.has(n)) {
        return;
      }
      markedAtoms.add(n);
      for (const m of getDependents(n)) {
        if (n !== m) {
          visit(m);
        }
      }
      topsortedAtoms.push(n);
    };
    visit(atom);
    const changedAtoms = /* @__PURE__ */ new Set([atom]);
    const isMarked = (a) => markedAtoms.has(a);
    for (let i = topsortedAtoms.length - 1; i >= 0; --i) {
      const a = topsortedAtoms[i];
      const prevAtomState = getAtomState(a);
      if (!prevAtomState) {
        continue;
      }
      let hasChangedDeps = false;
      for (const dep of prevAtomState.d.keys()) {
        if (dep !== a && changedAtoms.has(dep)) {
          hasChangedDeps = true;
          break;
        }
      }
      if (hasChangedDeps) {
        const nextAtomState = readAtomState(a, isMarked);
        addPendingDependent(a, nextAtomState);
        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {
          changedAtoms.add(a);
        }
      }
      markedAtoms.delete(a);
    }
  };
  const writeAtomState = (atom, ...args) => {
    const getter = (a) => returnAtomValue(readAtomState(a));
    const setter = (a, ...args2) => {
      const isSync = pendingStack.length > 0;
      if (!isSync) {
        pendingStack.push(/* @__PURE__ */ new Set([a]));
      }
      let r;
      if (isSelfAtom(atom, a)) {
        if (!hasInitialValue(a)) {
          throw new Error("atom not writable");
        }
        const prevAtomState = getAtomState(a);
        const nextAtomState = setAtomValueOrPromise(a, args2[0]);
        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {
          recomputeDependents(a);
        }
      } else {
        r = writeAtomState(a, ...args2);
      }
      if (!isSync) {
        const flushed = flushPending(pendingStack.pop());
        if (( false ? 0 : void 0) !== "production") {
          devListenersRev2.forEach(
            (l) => l({ type: "async-write", flushed })
          );
        }
      }
      return r;
    };
    const result = atom.write(getter, setter, ...args);
    return result;
  };
  const writeAtom = (atom, ...args) => {
    pendingStack.push(/* @__PURE__ */ new Set([atom]));
    const result = writeAtomState(atom, ...args);
    const flushed = flushPending(pendingStack.pop());
    if (( false ? 0 : void 0) !== "production") {
      devListenersRev2.forEach((l) => l({ type: "write", flushed }));
    }
    return result;
  };
  const mountAtom = (atom, initialDependent, onMountQueue) => {
    var _a;
    const existingMount = mountedMap.get(atom);
    if (existingMount) {
      if (initialDependent) {
        existingMount.t.add(initialDependent);
      }
      return existingMount;
    }
    const queue = onMountQueue || [];
    (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a) => {
      if (a !== atom) {
        mountAtom(a, atom, queue);
      }
    });
    readAtomState(atom);
    const mounted = {
      t: new Set(initialDependent && [initialDependent]),
      l: /* @__PURE__ */ new Set()
    };
    mountedMap.set(atom, mounted);
    if (( false ? 0 : void 0) !== "production") {
      mountedAtoms.add(atom);
    }
    if (isActuallyWritableAtom(atom) && atom.onMount) {
      const { onMount } = atom;
      queue.push(() => {
        const onUnmount = onMount((...args) => writeAtom(atom, ...args));
        if (onUnmount) {
          mounted.u = onUnmount;
        }
      });
    }
    if (!onMountQueue) {
      queue.forEach((f) => f());
    }
    return mounted;
  };
  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));
  const tryUnmountAtom = (atom, mounted) => {
    if (!canUnmountAtom(atom, mounted)) {
      return;
    }
    const onUnmount = mounted.u;
    if (onUnmount) {
      onUnmount();
    }
    mountedMap.delete(atom);
    if (( false ? 0 : void 0) !== "production") {
      mountedAtoms.delete(atom);
    }
    const atomState = getAtomState(atom);
    if (atomState) {
      if (hasPromiseAtomValue(atomState)) {
        cancelPromise(atomState.v);
      }
      atomState.d.forEach((_, a) => {
        if (a !== atom) {
          const mountedDep = mountedMap.get(a);
          if (mountedDep) {
            mountedDep.t.delete(atom);
            tryUnmountAtom(a, mountedDep);
          }
        }
      });
    } else if (( false ? 0 : void 0) !== "production") {
      console.warn("[Bug] could not find atom state to unmount", atom);
    }
  };
  const mountDependencies = (atom, atomState, prevDependencies) => {
    const depSet = new Set(atomState.d.keys());
    const maybeUnmountAtomSet = /* @__PURE__ */ new Set();
    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {
      if (depSet.has(a)) {
        depSet.delete(a);
        return;
      }
      maybeUnmountAtomSet.add(a);
      const mounted = mountedMap.get(a);
      if (mounted) {
        mounted.t.delete(atom);
      }
    });
    depSet.forEach((a) => {
      mountAtom(a, atom);
    });
    maybeUnmountAtomSet.forEach((a) => {
      const mounted = mountedMap.get(a);
      if (mounted) {
        tryUnmountAtom(a, mounted);
      }
    });
  };
  const flushPending = (pendingAtoms) => {
    let flushed;
    if (( false ? 0 : void 0) !== "production") {
      flushed = /* @__PURE__ */ new Set();
    }
    const pending = [];
    const collectPending = (pendingAtom) => {
      var _a;
      if (!pendingMap.has(pendingAtom)) {
        return;
      }
      const [prevAtomState, dependents] = pendingMap.get(pendingAtom);
      pendingMap.delete(pendingAtom);
      pending.push([pendingAtom, prevAtomState]);
      dependents.forEach(collectPending);
      (_a = getAtomState(pendingAtom)) == null ? void 0 : _a.d.forEach((_, a) => collectPending(a));
    };
    pendingAtoms.forEach(collectPending);
    pending.forEach(([atom, prevAtomState]) => {
      const atomState = getAtomState(atom);
      if (!atomState) {
        if (( false ? 0 : void 0) !== "production") {
          console.warn("[Bug] no atom state to flush");
        }
        return;
      }
      if (atomState !== prevAtomState) {
        const mounted = mountedMap.get(atom);
        if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {
          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);
        }
        if (mounted && !// TODO This seems pretty hacky. Hope to fix it.
        // Maybe we could `mountDependencies` in `setAtomState`?
        (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {
          mounted.l.forEach((listener) => listener());
          if (( false ? 0 : void 0) !== "production") {
            flushed.add(atom);
          }
        }
      }
    });
    if (( false ? 0 : void 0) !== "production") {
      return flushed;
    }
  };
  const subscribeAtom = (atom, listener) => {
    const mounted = mountAtom(atom);
    const flushed = flushPending([atom]);
    const listeners = mounted.l;
    listeners.add(listener);
    if (( false ? 0 : void 0) !== "production") {
      devListenersRev2.forEach(
        (l) => l({ type: "sub", flushed })
      );
    }
    return () => {
      listeners.delete(listener);
      tryUnmountAtom(atom, mounted);
      if (( false ? 0 : void 0) !== "production") {
        devListenersRev2.forEach((l) => l({ type: "unsub" }));
      }
    };
  };
  if (( false ? 0 : void 0) !== "production") {
    return {
      get: readAtom,
      set: writeAtom,
      sub: subscribeAtom,
      // store dev methods (these are tentative and subject to change without notice)
      dev_subscribe_store: (l) => {
        devListenersRev2.add(l);
        return () => {
          devListenersRev2.delete(l);
        };
      },
      dev_get_mounted_atoms: () => mountedAtoms.values(),
      dev_get_atom_state: (a) => atomStateMap.get(a),
      dev_get_mounted: (a) => mountedMap.get(a),
      dev_restore_atoms: (values) => {
        pendingStack.push(/* @__PURE__ */ new Set());
        for (const [atom, valueOrPromise] of values) {
          if (hasInitialValue(atom)) {
            setAtomValueOrPromise(atom, valueOrPromise);
            recomputeDependents(atom);
          }
        }
        const flushed = flushPending(pendingStack.pop());
        devListenersRev2.forEach(
          (l) => l({ type: "restore", flushed })
        );
      }
    };
  }
  return {
    get: readAtom,
    set: writeAtom,
    sub: subscribeAtom
  };
};
let defaultStore;
const getDefaultStore$1 = () => {
  if (!defaultStore) {
    defaultStore = createStore$1();
    if (( false ? 0 : void 0) !== "production") {
      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);
      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {
        console.warn(
          "Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"
        );
      }
    }
  }
  return defaultStore;
};

Symbol(
  ( false ? 0 : void 0) !== "production" ? "CONTINUE_PROMISE" : ""
);

const createStore = createStore$1;
const getDefaultStore = getDefaultStore$1;




/***/ }),

/***/ "./node_modules/js-cookie/dist/js.cookie.mjs":
/*!***************************************************!*\
  !*** ./node_modules/js-cookie/dist/js.cookie.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ api)
/* harmony export */ });
/*! js-cookie v3.0.5 | MIT */
/* eslint-disable no-var */
function assign (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      target[key] = source[key];
    }
  }
  return target
}
/* eslint-enable no-var */

/* eslint-disable no-var */
var defaultConverter = {
  read: function (value) {
    if (value[0] === '"') {
      value = value.slice(1, -1);
    }
    return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent)
  },
  write: function (value) {
    return encodeURIComponent(value).replace(
      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
      decodeURIComponent
    )
  }
};
/* eslint-enable no-var */

/* eslint-disable no-var */

function init (converter, defaultAttributes) {
  function set (name, value, attributes) {
    if (typeof document === 'undefined') {
      return
    }

    attributes = assign({}, defaultAttributes, attributes);

    if (typeof attributes.expires === 'number') {
      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
    }
    if (attributes.expires) {
      attributes.expires = attributes.expires.toUTCString();
    }

    name = encodeURIComponent(name)
      .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)
      .replace(/[()]/g, escape);

    var stringifiedAttributes = '';
    for (var attributeName in attributes) {
      if (!attributes[attributeName]) {
        continue
      }

      stringifiedAttributes += '; ' + attributeName;

      if (attributes[attributeName] === true) {
        continue
      }

      // Considers RFC 6265 section 5.2:
      // ...
      // 3.  If the remaining unparsed-attributes contains a %x3B (";")
      //     character:
      // Consume the characters of the unparsed-attributes up to,
      // not including, the first %x3B (";") character.
      // ...
      stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
    }

    return (document.cookie =
      name + '=' + converter.write(value, name) + stringifiedAttributes)
  }

  function get (name) {
    if (typeof document === 'undefined' || (arguments.length && !name)) {
      return
    }

    // To prevent the for loop in the first place assign an empty array
    // in case there are no cookies at all.
    var cookies = document.cookie ? document.cookie.split('; ') : [];
    var jar = {};
    for (var i = 0; i < cookies.length; i++) {
      var parts = cookies[i].split('=');
      var value = parts.slice(1).join('=');

      try {
        var found = decodeURIComponent(parts[0]);
        jar[found] = converter.read(value, found);

        if (name === found) {
          break
        }
      } catch (e) {}
    }

    return name ? jar[name] : jar
  }

  return Object.create(
    {
      set,
      get,
      remove: function (name, attributes) {
        set(
          name,
          '',
          assign({}, attributes, {
            expires: -1
          })
        );
      },
      withAttributes: function (attributes) {
        return init(this.converter, assign({}, this.attributes, attributes))
      },
      withConverter: function (converter) {
        return init(assign({}, this.converter, converter), this.attributes)
      }
    },
    {
      attributes: { value: Object.freeze(defaultAttributes) },
      converter: { value: Object.freeze(converter) }
    }
  )
}

var api = init(defaultConverter, { path: '/' });
/* eslint-enable no-var */




/***/ })

}]);