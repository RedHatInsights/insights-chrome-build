{"version":3,"file":"ajs-destination.e4bc16b79cc5e7e9.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfwE;AACF;AACV;AACK;AACf;AACA;AACmB;AACZ;AACd;AACc;AACmB;AAChB;AACuE;AAC3E;AAC4C;AAC1B;AACR;AAClE;AACA,WAAW,gDAAS;AACpB;AACA;AACA,eAAe,kDAAW;AAC1B;AACA;AACA;AACA,wBAAwB,2DAAS;AACjC;AACA;AACA,yCAAyC,oDAAM,eAAe,2BAA2B,0DAAQ,KAAK,gBAAgB,OAAO,gDAAS;AACtI;AACA,mCAAmC,kDAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,gEAAO;AACpE;AACA;AACA,oEAAoE,kDAAO;AAC3E;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB,IAAI;AAC7B;AACA;AACA;AACA;AACA;AACA,wDAAwD,uCAAuC;AAC/F;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,iCAAiC,gFAAc;AAC/C;AACA;AACA;AACA,wBAAwB,+CAAQ,GAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,8CAA8C,iBAAiB;AACtI;AACA;AACA,kBAAkB,8DAAa;AAC/B,kBAAkB,iFAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,QAAQ,iFAAiF;AAC1J;AACA;AACA;AACA,eAAe,gDAAS;AACxB;AACA;AACA,mBAAmB,kDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,wDAAe;AAChE;AACA;AACA;AACA;AACA;AACA,2CAA2C,yDAAgB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA,4BAA4B,oFAAuB;AACnD;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,4BAA4B,oFAAuB;AACnD;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,eAAe,0DAAiB;AAChC;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2DAAS;AACtB;AACA;AACA;AACA,eAAe,gDAAS;AACxB;AACA,mBAAmB,kDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+EAAkB;AACnD,gEAAgE,+CAAQ,CAAC,+CAAQ,GAAG,6BAA6B,gCAAgC;AACjJ,+CAA+C,8DAAkB;AACjE;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,gEAAgE,+CAAQ,CAAC,+CAAQ,GAAG;AACpF;AACA;AACA,+CAA+C,8DAAkB;AACjE;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,6CAA6C,wEAA0B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,wBAAwB,oFAAuB;AAC/C;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oFAAuB;AAC/C;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,eAAe,gDAAS;AACxB,mBAAmB,kDAAW;AAC9B,qDAAqD,kDAAK;AAC1D,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,eAAe,gDAAS;AACxB,mBAAmB,kDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,iDAAI;AACjE;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,eAAe,gDAAS;AACxB,mBAAmB,kDAAW;AAC9B,qDAAqD,qDAAQ;AAC7D,aAAa;AACb,SAAS;AACT;AACA;AACA,eAAe,gDAAS;AACxB,mBAAmB,kDAAW;AAC9B,qDAAqD,kDAAK;AAC1D,aAAa;AACb,SAAS;AACT;AACA;AACA,eAAe,gDAAS;AACxB,mBAAmB,kDAAW;AAC9B,qDAAqD,kDAAK;AAC1D,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO,gDAAS;AACjD;AACA,mBAAmB,kDAAW;AAC9B;AACA;AACA,4BAA4B,2DAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS,IAAI;AACb;AACA;AACA,CAAC;AAC4B;AACtB;AACP;AACA,yCAAyC;AACzC,8BAA8B;AAC9B,QAAQ,4DAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mEAAa,gEAAgE;AAC1G;AACA;AACA,gBAAgB,+CAAQ,CAAC,+CAAQ,GAAG,gBAAgB,KAAK,yEAAgC;AACzF,KAAK,IAAI;AACT,0CAA0C,oDAAa,CAAC,oDAAa;AACrE,eAAe,iEAAwB;AACvC,KAAK,mDAAmD;AACxD,eAAe,uEAAa;AAC5B,YAAY,uEAAa;AACzB,KAAK;AACL;AACA,kCAAkC,QAAQ,8DAAqB,6BAA6B;AAC5F;AACA;AACA,sBAAsB,uDAAc;AACpC;AACA,4DAA4D,uCAAuC;AACnG;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;AC/V8D;AACD;AACI;AACjE;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,oDAAa;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gCAAgC,kCAAkC;AAClE,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,gDAAS;AACpB;AACA,eAAe,kDAAW;AAC1B;AACA;AACA;AACA;AACA,2BAA2B,sEAAsB;AACjD;AACA;AACA;AACA;AACA,yCAAyC,4DAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,OAAO,4DAAU,uBAAuB;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP,WAAW,gDAAS;AACpB;AACA,eAAe,kDAAW;AAC1B,mBAAmB,sEAAsB;AACzC;AACA;AACA;AACA,kCAAkC,8DAAY;AAC9C,SAAS;AACT,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA","sources":["webpack://insights-chrome/./node_modules/@segment/analytics-next/dist/pkg/lib/is-plan-event-enabled.js","webpack://insights-chrome/./node_modules/@segment/analytics-next/dist/pkg/plugins/ajs-destination/index.js","webpack://insights-chrome/./node_modules/@segment/analytics-next/dist/pkg/plugins/ajs-destination/loader.js","webpack://insights-chrome/./node_modules/@segment/analytics-next/dist/pkg/plugins/ajs-destination/utils.js"],"sourcesContent":["/**\n * Determines whether a track event is allowed to be sent based on the\n * user's tracking plan.\n * If the user does not have a tracking plan or the event is allowed based\n * on the tracking plan configuration, returns true.\n */\nexport function isPlanEventEnabled(plan, planEvent) {\n    var _a, _b;\n    // Always prioritize the event's `enabled` status\n    if (typeof (planEvent === null || planEvent === void 0 ? void 0 : planEvent.enabled) === 'boolean') {\n        return planEvent.enabled;\n    }\n    // Assume absence of a tracking plan means events are enabled\n    return (_b = (_a = plan === null || plan === void 0 ? void 0 : plan.__default) === null || _a === void 0 ? void 0 : _a.enabled) !== null && _b !== void 0 ? _b : true;\n}\n//# sourceMappingURL=is-plan-event-enabled.js.map","import { __assign, __awaiter, __generator, __spreadArray } from \"tslib\";\nimport { Alias, Group, Identify, Page, Track } from '@segment/facade';\nimport { isOffline, isOnline } from '../../core/connection';\nimport { Context, ContextCancelation } from '../../core/context';\nimport { isServer } from '../../core/environment';\nimport { attempt } from '@segment/analytics-core';\nimport { isPlanEventEnabled } from '../../lib/is-plan-event-enabled';\nimport { mergedOptions } from '../../lib/merged-options';\nimport { pWhile } from '../../lib/p-while';\nimport { PriorityQueue } from '../../lib/priority-queue';\nimport { PersistedPriorityQueue } from '../../lib/priority-queue/persisted';\nimport { applyDestinationMiddleware, } from '../middleware';\nimport { buildIntegration, loadIntegration, resolveIntegrationNameFromSource, resolveVersion, unloadIntegration, } from './loader';\nimport { isPlainObject } from '@segment/analytics-core';\nimport { isDisabledIntegration as shouldSkipIntegration, isInstallableIntegration, } from './utils';\nimport { recordIntegrationMetric } from '../../core/stats/metric-helpers';\nimport { createDeferred } from '@segment/analytics-generic-utils';\nfunction flushQueue(xt, queue) {\n    return __awaiter(this, void 0, void 0, function () {\n        var failedQueue;\n        var _this = this;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    failedQueue = [];\n                    if (isOffline()) {\n                        return [2 /*return*/, queue];\n                    }\n                    return [4 /*yield*/, pWhile(function () { return queue.length > 0 && isOnline(); }, function () { return __awaiter(_this, void 0, void 0, function () {\n                            var ctx, result, success;\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0:\n                                        ctx = queue.pop();\n                                        if (!ctx) {\n                                            return [2 /*return*/];\n                                        }\n                                        return [4 /*yield*/, attempt(ctx, xt)];\n                                    case 1:\n                                        result = _a.sent();\n                                        success = result instanceof Context;\n                                        if (!success) {\n                                            failedQueue.push(ctx);\n                                        }\n                                        return [2 /*return*/];\n                                }\n                            });\n                        }); })\n                        // re-add failed tasks\n                    ];\n                case 1:\n                    _a.sent();\n                    // re-add failed tasks\n                    failedQueue.map(function (failed) { return queue.pushWithBackoff(failed); });\n                    return [2 /*return*/, queue];\n            }\n        });\n    });\n}\nvar LegacyDestination = /** @class */ (function () {\n    function LegacyDestination(name, version, writeKey, settings, options, integrationSource) {\n        if (settings === void 0) { settings = {}; }\n        var _this = this;\n        this.options = {};\n        this.type = 'destination';\n        this.middleware = [];\n        this.initializePromise = createDeferred();\n        this.flushing = false;\n        this.name = name;\n        this.version = version;\n        this.settings = __assign({}, settings);\n        this.disableAutoISOConversion = options.disableAutoISOConversion || false;\n        this.integrationSource = integrationSource;\n        // AJS-Renderer sets an extraneous `type` setting that clobbers\n        // existing type defaults. We need to remove it if it's present\n        if (this.settings['type'] && this.settings['type'] === 'browser') {\n            delete this.settings['type'];\n        }\n        this.initializePromise.promise.then(function (isInitialized) { return (_this._initialized = isInitialized); }, function () { });\n        this.options = options;\n        this.buffer = options.disableClientPersistence\n            ? new PriorityQueue(4, [])\n            : new PersistedPriorityQueue(4, \"\".concat(writeKey, \":dest-\").concat(name));\n        this.scheduleFlush();\n    }\n    LegacyDestination.prototype.isLoaded = function () {\n        return !!this._ready;\n    };\n    LegacyDestination.prototype.ready = function () {\n        var _this = this;\n        return this.initializePromise.promise.then(function () { var _a; return (_a = _this.onReady) !== null && _a !== void 0 ? _a : Promise.resolve(); });\n    };\n    LegacyDestination.prototype.load = function (ctx, analyticsInstance) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var integrationSource, _b;\n            var _this = this;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        if (this._ready || this.onReady !== undefined) {\n                            return [2 /*return*/];\n                        }\n                        if (!((_a = this.integrationSource) !== null && _a !== void 0)) return [3 /*break*/, 1];\n                        _b = _a;\n                        return [3 /*break*/, 3];\n                    case 1: return [4 /*yield*/, loadIntegration(ctx, this.name, this.version, this.options.obfuscate)];\n                    case 2:\n                        _b = (_c.sent());\n                        _c.label = 3;\n                    case 3:\n                        integrationSource = _b;\n                        this.integration = buildIntegration(integrationSource, this.settings, analyticsInstance);\n                        this.onReady = new Promise(function (resolve) {\n                            var onReadyFn = function () {\n                                _this._ready = true;\n                                resolve(true);\n                            };\n                            _this.integration.once('ready', onReadyFn);\n                        });\n                        this.integration.on('initialize', function () {\n                            _this.initializePromise.resolve(true);\n                        });\n                        try {\n                            recordIntegrationMetric(ctx, {\n                                integrationName: this.name,\n                                methodName: 'initialize',\n                                type: 'classic',\n                            });\n                            this.integration.initialize();\n                        }\n                        catch (error) {\n                            recordIntegrationMetric(ctx, {\n                                integrationName: this.name,\n                                methodName: 'initialize',\n                                type: 'classic',\n                                didError: true,\n                            });\n                            this.initializePromise.resolve(false);\n                            throw error;\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    LegacyDestination.prototype.unload = function (_ctx, _analyticsInstance) {\n        return unloadIntegration(this.name, this.version, this.options.obfuscate);\n    };\n    LegacyDestination.prototype.addMiddleware = function () {\n        var _a;\n        var fn = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            fn[_i] = arguments[_i];\n        }\n        this.middleware = (_a = this.middleware).concat.apply(_a, fn);\n    };\n    LegacyDestination.prototype.shouldBuffer = function (ctx) {\n        return (\n        // page events can't be buffered because of destinations that automatically add page views\n        ctx.event.type !== 'page' &&\n            (isOffline() || this._ready !== true || this._initialized !== true));\n    };\n    LegacyDestination.prototype.send = function (ctx, clz, eventType) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function () {\n            var plan, ev, planEvent, afterMiddleware, event, err_1;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        if (this.shouldBuffer(ctx)) {\n                            this.buffer.push(ctx);\n                            this.scheduleFlush();\n                            return [2 /*return*/, ctx];\n                        }\n                        plan = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.plan) === null || _b === void 0 ? void 0 : _b.track;\n                        ev = ctx.event.event;\n                        if (plan && ev && this.name !== 'Segment.io') {\n                            planEvent = plan[ev];\n                            if (!isPlanEventEnabled(plan, planEvent)) {\n                                ctx.updateEvent('integrations', __assign(__assign({}, ctx.event.integrations), { All: false, 'Segment.io': true }));\n                                ctx.cancel(new ContextCancelation({\n                                    retry: false,\n                                    reason: \"Event \".concat(ev, \" disabled for integration \").concat(this.name, \" in tracking plan\"),\n                                    type: 'Dropped by plan',\n                                }));\n                            }\n                            else {\n                                ctx.updateEvent('integrations', __assign(__assign({}, ctx.event.integrations), planEvent === null || planEvent === void 0 ? void 0 : planEvent.integrations));\n                            }\n                            if ((planEvent === null || planEvent === void 0 ? void 0 : planEvent.enabled) && (planEvent === null || planEvent === void 0 ? void 0 : planEvent.integrations[this.name]) === false) {\n                                ctx.cancel(new ContextCancelation({\n                                    retry: false,\n                                    reason: \"Event \".concat(ev, \" disabled for integration \").concat(this.name, \" in tracking plan\"),\n                                    type: 'Dropped by plan',\n                                }));\n                            }\n                        }\n                        return [4 /*yield*/, applyDestinationMiddleware(this.name, ctx.event, this.middleware)];\n                    case 1:\n                        afterMiddleware = _c.sent();\n                        if (afterMiddleware === null) {\n                            return [2 /*return*/, ctx];\n                        }\n                        event = new clz(afterMiddleware, {\n                            traverse: !this.disableAutoISOConversion,\n                        });\n                        recordIntegrationMetric(ctx, {\n                            integrationName: this.name,\n                            methodName: eventType,\n                            type: 'classic',\n                        });\n                        _c.label = 2;\n                    case 2:\n                        _c.trys.push([2, 5, , 6]);\n                        if (!this.integration) return [3 /*break*/, 4];\n                        return [4 /*yield*/, this.integration.invoke.call(this.integration, eventType, event)];\n                    case 3:\n                        _c.sent();\n                        _c.label = 4;\n                    case 4: return [3 /*break*/, 6];\n                    case 5:\n                        err_1 = _c.sent();\n                        recordIntegrationMetric(ctx, {\n                            integrationName: this.name,\n                            methodName: eventType,\n                            type: 'classic',\n                            didError: true,\n                        });\n                        throw err_1;\n                    case 6: return [2 /*return*/, ctx];\n                }\n            });\n        });\n    };\n    LegacyDestination.prototype.track = function (ctx) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.send(ctx, Track, 'track')];\n            });\n        });\n    };\n    LegacyDestination.prototype.page = function (ctx) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (((_a = this.integration) === null || _a === void 0 ? void 0 : _a._assumesPageview) && !this._initialized) {\n                            this.integration.initialize();\n                        }\n                        return [4 /*yield*/, this.initializePromise.promise];\n                    case 1:\n                        _b.sent();\n                        return [2 /*return*/, this.send(ctx, Page, 'page')];\n                }\n            });\n        });\n    };\n    LegacyDestination.prototype.identify = function (ctx) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.send(ctx, Identify, 'identify')];\n            });\n        });\n    };\n    LegacyDestination.prototype.alias = function (ctx) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.send(ctx, Alias, 'alias')];\n            });\n        });\n    };\n    LegacyDestination.prototype.group = function (ctx) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.send(ctx, Group, 'group')];\n            });\n        });\n    };\n    LegacyDestination.prototype.scheduleFlush = function () {\n        var _this = this;\n        if (this.flushing) {\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (isOffline() || this._ready !== true || this._initialized !== true) {\n                            this.scheduleFlush();\n                            return [2 /*return*/];\n                        }\n                        this.flushing = true;\n                        _a = this;\n                        return [4 /*yield*/, flushQueue(this, this.buffer)];\n                    case 1:\n                        _a.buffer = _b.sent();\n                        this.flushing = false;\n                        if (this.buffer.todo > 0) {\n                            this.scheduleFlush();\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        }); }, Math.random() * 5000);\n    };\n    return LegacyDestination;\n}());\nexport { LegacyDestination };\nexport function ajsDestinations(writeKey, settings, globalIntegrations, options, routingMiddleware, legacyIntegrationSources) {\n    var _a, _b;\n    if (globalIntegrations === void 0) { globalIntegrations = {}; }\n    if (options === void 0) { options = {}; }\n    if (isServer()) {\n        return [];\n    }\n    if (settings.plan) {\n        options = options !== null && options !== void 0 ? options : {};\n        options.plan = settings.plan;\n    }\n    var routingRules = (_b = (_a = settings.middlewareSettings) === null || _a === void 0 ? void 0 : _a.routingRules) !== null && _b !== void 0 ? _b : [];\n    var remoteIntegrationsConfig = settings.integrations;\n    var localIntegrationsConfig = options.integrations;\n    // merged remote CDN settings with user provided options\n    var integrationOptions = mergedOptions(settings, options !== null && options !== void 0 ? options : {});\n    var adhocIntegrationSources = legacyIntegrationSources === null || legacyIntegrationSources === void 0 ? void 0 : legacyIntegrationSources.reduce(function (acc, integrationSource) {\n        var _a;\n        return (__assign(__assign({}, acc), (_a = {}, _a[resolveIntegrationNameFromSource(integrationSource)] = integrationSource, _a)));\n    }, {});\n    var installableIntegrations = new Set(__spreadArray(__spreadArray([], Object.keys(remoteIntegrationsConfig).filter(function (name) {\n        return isInstallableIntegration(name, remoteIntegrationsConfig[name]);\n    }), true), Object.keys(adhocIntegrationSources || {}).filter(function (name) {\n        return isPlainObject(remoteIntegrationsConfig[name]) ||\n            isPlainObject(localIntegrationsConfig === null || localIntegrationsConfig === void 0 ? void 0 : localIntegrationsConfig[name]);\n    }), true));\n    return Array.from(installableIntegrations)\n        .filter(function (name) { return !shouldSkipIntegration(name, globalIntegrations); })\n        .map(function (name) {\n        var integrationSettings = remoteIntegrationsConfig[name];\n        var version = resolveVersion(integrationSettings);\n        var destination = new LegacyDestination(name, version, writeKey, integrationOptions[name], options, adhocIntegrationSources === null || adhocIntegrationSources === void 0 ? void 0 : adhocIntegrationSources[name]);\n        var routing = routingRules.filter(function (rule) { return rule.destinationName === name; });\n        if (routing.length > 0 && routingMiddleware) {\n            destination.addMiddleware(routingMiddleware);\n        }\n        return destination;\n    });\n}\n//# sourceMappingURL=index.js.map","import { __awaiter, __generator, __spreadArray } from \"tslib\";\nimport { getNextIntegrationsURL } from '../../lib/parse-cdn';\nimport { loadScript, unloadScript } from '../../lib/load-script';\nfunction normalizeName(name) {\n    return name.toLowerCase().replace('.', '').replace(/\\s+/g, '-');\n}\nfunction obfuscatePathName(pathName, obfuscate) {\n    if (obfuscate === void 0) { obfuscate = false; }\n    return obfuscate ? btoa(pathName).replace(/=/g, '') : undefined;\n}\nexport function resolveIntegrationNameFromSource(integrationSource) {\n    return ('Integration' in integrationSource\n        ? integrationSource.Integration\n        : integrationSource).prototype.name;\n}\nfunction recordLoadMetrics(fullPath, ctx, name) {\n    var _a, _b;\n    try {\n        var metric = ((_b = (_a = window === null || window === void 0 ? void 0 : window.performance) === null || _a === void 0 ? void 0 : _a.getEntriesByName(fullPath, 'resource')) !== null && _b !== void 0 ? _b : [])[0];\n        // we assume everything that took under 100ms is cached\n        metric &&\n            ctx.stats.gauge('legacy_destination_time', Math.round(metric.duration), __spreadArray([\n                name\n            ], (metric.duration < 100 ? ['cached'] : []), true));\n    }\n    catch (_) {\n        // not available\n    }\n}\nexport function buildIntegration(integrationSource, integrationSettings, analyticsInstance) {\n    var integrationCtr;\n    // GA and Appcues use a different interface to instantiating integrations\n    if ('Integration' in integrationSource) {\n        var analyticsStub = {\n            user: function () { return analyticsInstance.user(); },\n            addIntegration: function () { },\n        };\n        integrationSource(analyticsStub);\n        integrationCtr = integrationSource.Integration;\n    }\n    else {\n        integrationCtr = integrationSource;\n    }\n    var integration = new integrationCtr(integrationSettings);\n    integration.analytics = analyticsInstance;\n    return integration;\n}\nexport function loadIntegration(ctx, name, version, obfuscate) {\n    return __awaiter(this, void 0, void 0, function () {\n        var pathName, obfuscatedPathName, path, fullPath, err_1, deps;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    pathName = normalizeName(name);\n                    obfuscatedPathName = obfuscatePathName(pathName, obfuscate);\n                    path = getNextIntegrationsURL();\n                    fullPath = \"\".concat(path, \"/integrations/\").concat(obfuscatedPathName !== null && obfuscatedPathName !== void 0 ? obfuscatedPathName : pathName, \"/\").concat(version, \"/\").concat(obfuscatedPathName !== null && obfuscatedPathName !== void 0 ? obfuscatedPathName : pathName, \".dynamic.js.gz\");\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 3, , 4]);\n                    return [4 /*yield*/, loadScript(fullPath)];\n                case 2:\n                    _a.sent();\n                    recordLoadMetrics(fullPath, ctx, name);\n                    return [3 /*break*/, 4];\n                case 3:\n                    err_1 = _a.sent();\n                    ctx.stats.gauge('legacy_destination_time', -1, [\"plugin:\".concat(name), \"failed\"]);\n                    throw err_1;\n                case 4:\n                    deps = window[\"\".concat(pathName, \"Deps\")];\n                    return [4 /*yield*/, Promise.all(deps.map(function (dep) { return loadScript(path + dep + '.gz'); }))\n                        // @ts-ignore\n                    ];\n                case 5:\n                    _a.sent();\n                    // @ts-ignore\n                    window[\"\".concat(pathName, \"Loader\")]();\n                    return [2 /*return*/, window[\n                        // @ts-ignore\n                        \"\".concat(pathName, \"Integration\")]];\n            }\n        });\n    });\n}\nexport function unloadIntegration(name, version, obfuscate) {\n    return __awaiter(this, void 0, void 0, function () {\n        var path, pathName, obfuscatedPathName, fullPath;\n        return __generator(this, function (_a) {\n            path = getNextIntegrationsURL();\n            pathName = normalizeName(name);\n            obfuscatedPathName = obfuscatePathName(name, obfuscate);\n            fullPath = \"\".concat(path, \"/integrations/\").concat(obfuscatedPathName !== null && obfuscatedPathName !== void 0 ? obfuscatedPathName : pathName, \"/\").concat(version, \"/\").concat(obfuscatedPathName !== null && obfuscatedPathName !== void 0 ? obfuscatedPathName : pathName, \".dynamic.js.gz\");\n            return [2 /*return*/, unloadScript(fullPath)];\n        });\n    });\n}\nexport function resolveVersion(integrationConfig) {\n    var _a, _b, _c, _d;\n    return ((_d = (_b = (_a = integrationConfig === null || integrationConfig === void 0 ? void 0 : integrationConfig.versionSettings) === null || _a === void 0 ? void 0 : _a.override) !== null && _b !== void 0 ? _b : (_c = integrationConfig === null || integrationConfig === void 0 ? void 0 : integrationConfig.versionSettings) === null || _c === void 0 ? void 0 : _c.version) !== null && _d !== void 0 ? _d : 'latest');\n}\n//# sourceMappingURL=loader.js.map","export var isInstallableIntegration = function (name, integrationSettings) {\n    var _a;\n    var type = integrationSettings.type, bundlingStatus = integrationSettings.bundlingStatus, versionSettings = integrationSettings.versionSettings;\n    // We use `!== 'unbundled'` (versus `=== 'bundled'`) to be inclusive of\n    // destinations without a defined value for `bundlingStatus`\n    var deviceMode = bundlingStatus !== 'unbundled' &&\n        (type === 'browser' || ((_a = versionSettings === null || versionSettings === void 0 ? void 0 : versionSettings.componentTypes) === null || _a === void 0 ? void 0 : _a.includes('browser')));\n    // checking for iterable is a quick fix we need in place to prevent\n    // errors showing Iterable as a failed destiantion. Ideally, we should\n    // fix the Iterable metadata instead, but that's a longer process.\n    return !name.startsWith('Segment') && name !== 'Iterable' && deviceMode;\n};\nexport var isDisabledIntegration = function (integrationName, globalIntegrations) {\n    var allDisableAndNotDefined = globalIntegrations.All === false &&\n        globalIntegrations[integrationName] === undefined;\n    return (globalIntegrations[integrationName] === false || allDisableAndNotDefined);\n};\n//# sourceMappingURL=utils.js.map"],"names":[],"sourceRoot":""}